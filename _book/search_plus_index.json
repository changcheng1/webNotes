{"./":{"url":"./","title":"Introduction","keywords":"","body":"学习笔记 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-13 17:48:00 "},"web/jsonp/":{"url":"web/jsonp/","title":"跨域","keywords":"","body":"多种跨域方案详解 同源策略 协议 域名 端口 一致 为什么浏览器不支持跨域 cookie LocalStorage都具有同源限制，防止cookie共享带来的安全性 // 跨域强制携带cookie xhr.withCredentials = true 实现跨域的几种方式 1. jsonp 缺点：1.只能发送get请求 2.容易遭受xss攻击 JSONP实现 // jsonp的实现 function jsonp({url,params,cb}){ return new Promise((resolve,reject)=>{ let script = document.createElement('script'); // 获取函数中的参数 window[cb] = function(data){ console.log(\"data\",data) resolve(data) document.removeChild(script) } params = {...params,cb} let arrs = [] for(let key in params){ arrs.push(`${key}=${params[key]}`) } script.src = `${url}?${arrs.join('&')}` document.body.appendChild(script) }) } jsonp({ url:'https://www.baidu.com/sugrec', params:{wd:'b'}, cb:'jQuery11020574908' }).then(data=>{ console.log(data) }) 2. cors 最常用的方式，后端设置Access-Control-Allow-Origin // 伪代码 let express = require('express'); let app = express() let whitList = ['http://www.baidu.com'] app.use((req,res,next)=>{ let origin = req.headers.origin; if(whitList.includes(origin)){ res.setHeader('Access-Control-Allow-Origin',origin) // 设置允许跨域携带cookit res.setHeader('Access-Control-Allow-Credentials',true) // 设置6秒之内不会发送options请求 res.setHeader('Access-Control-Max-age',6) // 支持headers中的name属性 res.setHeader('Access-Control-Expose-Headers','name') // 三种情况会出现预请求 // 1.请求的方式不是GET/POST/HEAD // 2.POST的请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain // 3.请求设置了自定义header if(req.method == 'options'){ res.send() } } }) 3. postMessage // A页面 function load(){ let frame = document.getElementById('frame'); frame.contentWindow.postMessage('传递给B页面的内容','http://localhost:4000'); } //监听B页面传递过来的消息 window.onmessage = function(e){ console.log(e.data); e.source.postMessage('我拒收了b页面的消息'，e.origin) } // B页面 window.onmessage = function(e){ console.log(e.data); e.source.postMessage('我拒收了A页面的消息'，e.origin) } 4. document.domain document.domain：返回当前文档的服务器域名 前提条件:这两个域名必须属于同一个基础域名，而且所用协议，端口都必须一致，否则无法使用documeng.domain进行跨域 前提条件满足之后利用document.domain设置为同一个一级域名就可以实现跨域 // 一级域名 http://www.baidu.com // 二级域名 http://movie.baidu.com // A页面 document.domain = 'zf1.cn' function load(){ var iframe = document.getElementById('frame'); console.log(iframe.contentWindow.a) } // B页面 document.domain = 'zf1.cn' var a = '123' ` 5. window.name // A和B是同域的 // C是不同域的 // a先获取C的数据 c把值放在window上面，然后把a的引用地址改到B,这样的话name不会消失 let first = true function load(){ if(first){ let iframe = document.getElementById('frame'); iframe.src = 'http://localhost:3000/b.html' first = false }else{ console.log(iframe.contentWindow.name) } } 6. locaiton.hash // 路径后面的hash值可以用来通信 // 目的是a想访问C,a和b页面是同源的 // a给c传一个hash值，c收到hash值后，C把Hash值传递给B，b将结果放到a到hash值中 // A页面 window.onhashchange = function(){ console.log(locaiton.hash) } // B页面 // 设置a页面的hash值，触发a页面的onhashchange方法拿到hash值 window.parent.parent.location.hash = location.hash // C页面 console.log(location.hash) // 这里可以获取A页面传递过来的hash值 let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe) 7. http-proxy 常见项目当中的解决跨域问题就是配置proxtT使用的就是http-proxy-middleware插件 8. nginx 高性能的HTTP和反向代理的服务器 9. websocket websocket和Http协议的区别 websocket是双向连接，Http是单向连接 // web var ws = new WebSocket(\"wss://echo.websocket.org\"); // 建立连接，发送消息 ws.open = function(evt){ console.log(\"Connection open ...\"); ws.sned(\"This is message\"); } // 监听收到的消息 ws.onmessage = function(evt){ console.log(\"Recived Message:\"+evt.data) ws.close() } // 监听关闭 ws.onclose = function(evt){ console.log(\"connection closed\") } // node let express = require('express'); let app = express(); let webSocket = require('ws'); let wss = new webSocket.Server({prt:3000}); wss.on('connection',function(ws){ wss.on('message',function(data){ console.log(\"data\",data) ws.end('发送给客户端的消息') }) }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-13 15:10:56 "},"web/arr/":{"url":"web/arr/","title":"数组方法","keywords":"","body":"常用数组方法 Array.of() Array.prototype.concat() Array.prototype.copyWithin() Array.prototype.entries() Array.prototype.every() Array.prototype.fill() Array.prototype.filter() Array.prototype.find() Array.prototype.findIndex() Array.prototype.flat() Array.prototype.flatMap() Array.prototype.forEach() Array.prototype.includes() Array.prototype.indexOf() Array.prototype.join() Array.prototype.keys() Array.prototype.lastIndexOf() Array.prototype.map() Array.prototype.pop() Array.prototype.push() Array.prototype.reduce() Array.prototype.reduceRight():区别于reduce是从右往左进行操作 Array.prototype.reverse() Array.prototype.shift() Array.prototype.slice() Array.prototype.some() Array.prototype.sort() Array.prototype.splice() Array.prototype.toLocaleString() Array.prototype.toString() Array.prototype.unshift() Array.prototype.values() Array.from() Array.isArray():结果返回true/false Array.reduce((prev,next,currentIndex,arr)={},initalValue) prev:初始值(必须) next:当前元素(必须) currentIndex:当前元素的索引(可选) arr:当前元素对象(可选) initalValue:当前元素对象(可选) // 数组求和 const arr = [1,2,3,4,5] const total = arr.reduce((prev,next)=>{ console.log(prev,next) return prev + next // return之后会改变下次的total },0) // 0 1 // 1 2 // 3 3 // 6 4 // 10 5 // 数组合并 const arr = [[1,2],[3,4],[5,6]]; const total = arr.reduce(function(newArr,itemArr){ return newArr.concat(itemArr) }, []); console.log('======total',total); //[1, 2, 3, 4, 5, 6] const arr = [\"aaa\", \"bbb\", \"ccc\"]; arr.reduce(function(prev,next){ console.log(\"prev:\",prev); console.log(\"next:\",next); return prev; // prev: 111 },'111'); // next: aaa // prev: 111 // next: bbb // prev: 111 // next: ccc Array.join() 将数组转化为字符串 var arr = [1,2,3,4] arr.join() // 1,2,3,4 arr.join('') // 1234 Array.slice(start,end) start:开始下标 end:结束下标 截取数组，不会改变改变原数组 var arr = [1,2,3,4] arr.slice(0,1) // 返回:[0,1] var arr1 = [1,2,3,4] arr1.slice() // 返回：[1,2,3,4] var arr2 = [1,2,3,4,5,6] arr2.slice(2,4) // 返回 [3,4] Array.splice(index,deleteMany,item1,...itemX) 截取数组，向数组添加元素，该方法会改变原数组 index:开始位置 deleteMany:删除的数量 item1,...itemX: 添加的项 var arr = [1,2,3,4] arr.splice(0,1,9) // 原数组：[9,2,3,4] 返回[1] var arr1 = [1,2,3,4] arr1.splice(0,1) // 原数组：[2,3,4] 返回:[1] var arr2 = [1,2,3,4,5,6] arr2.splice(2,4) // 返回：[3,4,5,6] Array.from() 该方法用于将两类对象转换成真正的数组：类数组的对象和可遍历对象 可以接受一个参数来对数组当中的每个元素进行单独处理 var obj = { 0:123, length:1 // length为必选项 } Array.from(obj) // 返回 [123] // 如果是ES5的实现 Array.prototype.slice.call(obj) //[123] // 传入函数针对每个参数进行单独处理 var arr = [1,false,false,4] Array.from(arr,(x)=>{ return x ? x : true // 返回[1,true,true,4] }) Array.of() 该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型 Array.of(1,2) // 返回[1,2] Array.of(undefined) // 返回[undefined] // ES5实现 function ArrayOf(){ return [].slice.call(arguments); } Array.copyWithin(target,start,end) target:从该位置替换数据，负值就是倒数 start:从该位置开始读取数据，默认为0，负值，从末尾开始计算 end:到该位置停止读取数据 // 将3号位复制到0号位 [1,2,3,4,5].copyWithin(0,1,2) // [2,2,3,4,5] [1,2,3,4,5].copyWithin(0,-2,-1) // [4,2,3,4,5] [1,2,3,4,5].copyWithin(1,3,4) // [1,4,3,4,5] Array.find()和Array.findIndex() 区别：Array.find()是返回符合条件的第一个成员 Array.findIndex()是返回符合条件成员的位置 // Array.find() [1,2,3,4,5].find((val)=>{ val>3 // 4 }) // Array.findIndex() [1,2,3,4,5].findIndex((val)=>{ val>3 // 3 }) // 这两个方法都可以接口第二个参数，用来绑定回调函数的this对象 function f(v){ return v > this.age } var obj = { age:20 } [19,23,21].findIndex(f,obj) // 返回：1 Arryay.fill(elem,start,end) elem:填充的数值(必填) start:开始填充的位置 end:结束的位置 [1,2,3].fill(4) // [4,4,4] [1,2,3].fill(9,2,3) // [1,2,9] entries(),keys(),values() // entreis() for(let [index,elem] of ['a','b'].entries()){ console.log(index,elem) // 0 'a' } // 1 'b' // keys() for(let elem of ['a','b'].keys()){ console.log(elem) // 0 1 } // values() for(let elem of ['a','b'].values()){ console.log(elem) // 'a' 'b' } Array.includes(elem,start) 判断数组里是否包含某项 返回true/false elem：查找的元素 start:起始位置 [1,2,3,4].includes(3) // true [1,2,3,4].includes(3,3) //false flat(),flatMap() flat():用来展开嵌套数组，会忽略空格会修改原数组 flatMap():flatMap 方法与 map 方法和深度depth为1的 flat 几乎相同. // flat():平铺数组 [1,[2,3,[4,5,[6]]]].flat(Infinity) // [1,2,3,4,5,6] // flatMap():可以忽略空格，map不忽略空格 let arr = [\"今天天气不错\", \"\", \"早上好\"] arr.map(s => s.split(\"\")) // [[\"今\", \"天\", \"天\", \"气\", \"不\", \"错\"],[],[\"早\", \"上\", \"好\"]] arr.flatMap(s => s.split('')); // [\"今\", \"天\", \"天\", \"气\", \"不\", \"错\", \"早\", \"上\", \"好\"] Array.map() 该方法创建一个新数组，结果是该数组中的每个元素调用一个函数返回的结果 var arr = [1,2,3,4] var newArr = arr.map(x=>{ return x * 2 }) console.log(newArr) //2,4,6,8 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-14 16:33:51 "},"web/string/":{"url":"web/string/","title":"字符串方法","keywords":"","body":"常用字符串方法 String.concat():字符串拼接 String.substr() String.substr(indexStart,indexEnd)不建议使用 indexStart:开始位置 indexEnd:截取的数量 var str = '123456' console.log(str.substr(2,3)) // 345 String.substring(indexStart,number) indexStart:开始下标 number:截取数量 var str = '123456789' console.log(str.substring(3,4)) // 4567 String.slice() var str = 'ThisisString' console.log(str.slice(3,5)) // si String.includes() String.startsWith() String.endsWith() includes():返回布尔值,是否找到了参数字符串 startsWith():返回布尔值,是否在头部找到了参数字符串 endsWith():返回布尔值,是否在尾部找到了参数字符串 var str ='Hello world!' // includes() console.log(str.includes(' wor')) //true // startsWith() console.log(str.startsWith('Hello')) //true // endsWith() console.log(str.endsWith('!')) //true String.repeat() 该方法返回一个新的字符串,表示将字符串重复N次 如果repeat的参数是负数或者Infinity，会报错 var str = '123' console.log(str.repeat(3)) // '123123123' trim String.trimStart() String.trimEnd() trim():从两端消除空格 trimStart():消除头部空格 trimEnd():消除尾部空格 都不会修改原字符串 const str = ' abc '; // trim() console.log(str.trim()) // 'abc' // trimStart() console.log(str.trimStart()) // 'abc ' // trimEnd console.log(str.trimEnd()) // ' abc' String.charAt() 从一个字符串中返回指定的字符 var anyString = \"Brave new world\"; console.log(\"The character at index 0 is '\" + anyString.charAt(0) + \"'\"); // The character at index 0 is 'B' console.log(\"The character at index 1 is '\" + anyString.charAt(1) + \"'\"); // The character at index 0 is 'r' console.log(\"The character at index 2 is '\" + anyString.charAt(2) + \"'\"); // The character at index 0 is 'a' console.log(\"The character at index 3 is '\" + anyString.charAt(3) + \"'\"); // The character at index 0 is 'v' console.log(\"The character at index 4 is '\" + anyString.charAt(4) + \"'\"); // The character at index 0 is 'e' console.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\"); // The character at index 0 is '' Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-18 13:59:03 "},"web/nginx/":{"url":"web/nginx/","title":"nginx","keywords":"","body":"nginx详解 nginx是一个开源而且高性能的、可靠的HTTP中间件和代理服务器 关闭iptables iptables命令是Linux上最常用的防火墙软件 停止防火墙: systemctl stop firewalled.service 永久关闭防火墙: systemctl disable firewalled.service 确认停用selinux 安全增强型的linux，是一个linux的内核模块，也是linux的一个安全子系统 停止:setenforce 0 安装linux所需模块 yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake yum -y install wget httpd-tools vim nginx的优势 IO多路复用 多个描述符的IO操作都能在一个线程里并发交替顺序完成，复用多线程 select线程(类似于轮询是否完成):线性遍历文件描述符列表1.效率低下2.最多只有1024 epoll(nginx模型):每当fd就绪，采用系统回调函数将fd放下1.效率高2.没有1024限制 编写linux配置 vi /etc/yum.repos.d/nginx.repo [nginx] name=nginx repo baseurl = http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0 enabled=1 安装nginx yum install nginx Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-18 11:33:00 "},"web/regExp/":{"url":"web/regExp/","title":"正则","keywords":"","body":"正则详解 每一个正则都是由\"元字符\",\"修饰符\",两部分组成 正则两个斜杠之间包起来的都是\"元字符\" 斜杠后面出现的都是\"修饰符\" 创建正则的两种方式 let reg1 = /^\\d+$/g; //字面量 let reg2 = new RegExp(\"^\\\\d+$\",\"g\") //构造函数方式 常用的修饰符 i:ignoreCase 忽略大小写匹配 m:multiline 多行匹配 g:global 全局匹配 常用的元字符 // [特殊元字符] \\D 非0-9之间的任意字符 \\d 0-9之间的一个数字 \\n 匹配一个换行符 \\b 匹配边界符 'zhu' (z左边u右边就是边界) \\s 匹配任意一个空白字符(包括制表符table键四个空格) \\w \"数字、字母、下划线\"中的任意一个 == ([0-9a-zA-Z]) \\ 转义字符(例如:\\d，把有特殊含义的字符转换为普通意思) . 代表是除了\\n以外任意字符 ^ 以某个元字符开头 $ 以某个元字符结尾 x|y x或者y中的任意一个 [xyz] x或者y或者z中的任意一个 [^xyz] 除了x/y/z以外任何一个字符 [a-z] 获取a-z中的任意字符 ([0-9] 等价于 \\d) [^a-z] 除了a-z之外的任意字符 () 正则分组 (?:) 当前分组只匹配不捕获 (?=) 正向预查 (?!) 反向预查 ...... // [量词元字符:让其左边的元字符出现多少次] * 出现零到多次 ？ 出现零到一次 + 出现一到多次 {n} 出现n次 {n,} 出现n到多次 {n,m} 出现n到m次 // [普通元字符] 只要在正则中出现的元字符，(在基于字面方式创建)，除了特殊和有量词意义的以外，其余的都是普通元字符 元字符 [ ] 详解 在[ ]中出现的元字符一般都是代表本身含义 [ ] 中出现的两位数，不是两位数，而是两个数字中的任意一个 // \\n 匹配换行符 let reg = /^\\n$/ console.log(reg.test('\\n')) //=>true console.log(reg.test('3')) //=>false console.log(reg.test('n')) //=>false //^开头 $结尾，那么代表的含义是只能是xx let reg = /^.$/ console.log(reg.test('n')) //=>true console.log(reg.test('1')) //=>true console.log(reg.test('\\n')) //=>false console.log(reg.test('nn')) //=>false // []中的字符有消除特殊含义的功能 let reg = /^[.]+$/ console.log(reg.test('..')) //=>true console.log(reg.test('n')) //=>false console.log(reg.test('1')) //=>false console.log(reg.test('\\n')) //=>false console.log(reg.test('nn')) //=>false // [\\d]依然是0-9中的一个数字 let reg = /^[\\d]$/ console.log(reg.test(0)) //=>true // [17] 匹配 1或者 7 let reg = /^[17]$/ console.log(reg.test('8')) //=>false console.log(reg.test('1')) //=>true console.log(reg.test('7')) //=>true // [12-93] 其实匹配的是 1或者3 2-9 let reg = /^[12-93]$/ console.log(reg.test('7')) //=>true // 匹配18-65岁之间 // 18~19 // 20~59 // 60~65 let reg = /^(1[89])|([2-5][0-9])|(6[0-5])$/ console.log(reg.test(\"55\")) // 匹配[Object AAAA] 必须使用\\转义 let reg = /^\\[object [A]{4}\\]$/ console.log(reg.test('[object AAAA]')) 常用正则 // 有效数字的正则 // 1.正数 负数 零 // 2.小数 整数 // 规则:1.可以出现+/-号，可以没有，也可以有一个 // 2.整数0 12 9：一位或者多位数字，一位0-9，多位数字不能以0开头 // 3.小数部分：可能有可能没有，有小数点后面至少要跟一位数字 let reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ console.log(reg.test('0.3')) // 手机号码的正则 // 1.11位数字 // 2.必须以1开头 let reg = /^1\\d{10}$/; console.log(reg.test(18554209912)) // 中文姓名的正则 // 1. [\\u4E00-\\U9FA5] 代表的是涵盖所有的中文 // 2.尼古拉斯·赵四 中间可能会有· let reg = /^[\\u4E00-\\u9FA5]{2,5}(·)?[\\u4E00-\\u9FA5]{2,}$/; console.log(reg.test('尼古拉斯·赵四')) console.log(reg.test('尼古拉斯')) exec() RegExp类的方法,传入要匹配的字符串 正则的捕获有懒惰性:执行一次exec()只能捕获第一个和正则匹配的内容，多次执行还是捕获第一个 不加g多次调用exec()方法也无法匹配到全部符合的字符串，加g可以多次执行exec()方法进行匹配符合的全部字符串，需要手动多次调用， // [ // '20190818', // index: 0, // input: '20190818changcheng2017', // groups: undefined // ] let reg = /\\d+/ let str = '20190818changcheng2017' // lastIndex导致了懒惰性只能捕获匹配的第一个 console.log(reg.exec(str)) 正则捕获的懒惰性 // exec():字符串捕获 let reg = /\\d+/ let str = '20190818changcheng2017' // lastIndex导致了懒惰性只能捕获匹配的第一个 console.log(reg.exec(str)[0]) //20190818 // 无法手动更改lastIndex实现全部捕获 reg.lastIndex = 17 console.log(reg.exec(str)[0]) // 20190818 // 解决惰性捕获添加g修饰符(唯一的方案，不加g不管用什么方法都没有办法全部匹配到) let reg = /\\d+/g; let str = '20190918chang20190817' console.log(reg.exec(str)) console.log(reg.exec(str)) let reg = /\\d+/g; let str = '20190918chang20190817cheng1807' // 完整的捕获方法实现 RegExp.prototype.myExecAll = function(str){ let result = [] valArray = this.exec(str) while(valArray){ result.push(valArray[0]) valArray = this.exec(str) } return result } console.log(reg.myExecAll(str)) 正则捕获的贪婪性 正则捕获还具有贪婪性，每一次匹配的时候，总是捕获到和正则匹配中最长的内容，例如:'2'符合/d+，'2019'也符合/d+，但是捕获的是最长的内容'2019' 把问号放到量词元字符后面，代表的不是出现0次或者1次了，而是取消捕获的贪婪性 // 可以匹配出全部的项 //[ '2019', index: 5, input: 'chang2019cheng', groups: undefined ] let str = 'chang2019cheng' let reg = /\\d+/g console.log(reg.exec(str)) // 加?可以取消正则匹配的贪婪性 //[ '2', index: 5, input: 'chang2019cheng', groups: undefined ] let str = 'chang2019cheng' let reg = /\\d+?/g console.log(reg.exec(str)) 分组捕获 //在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到(数组的第一项)， // 而且把小分组匹配到的内容也单独抽出来(数组中的第二项开始就是小分组) let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/g console.log(reg.exec(str)) // [ // '{123}', // '123', // index: 4, // input: '2018{123}{456}', // groups: undefined // ] match() String类的方法,参数是正则 不加g只能匹配到第一个符合的项，加g可以匹配出所有符合的项 match方法也有自己的局限性，在正则设置了g的情况下，基于match捕获的内容只有大正则匹配的的，小分组的没有单独抽离出来， （不设置g的情况下和执行exec()是一样的） // 设置g的情况下 // [ '{123}', '{456}' ] let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/g console.log(str.match(reg)) // [ // '{123}', // '123', // index: 4, // input: '2018{123}{456}', // groups: undefined // ] let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/ console.log(str.match(reg)) ？的作用 1.量词元字符:出现0次到1次 /-?/:让减号出现一次或者不出现 2.取消贪婪性 /\\d+?/:捕获的时候只捕获最短匹配的内容 3.?:只匹配不捕获 4.?=:正向预查 5.?!:负向预查 lastIndex的影响 // 调用test()方法之后，lastIndex值也会改变 let str = 'chang2019cheng2020'; let reg = /\\d+/g; console.log(reg.test(str)); // true 这里也相当于捕获修改了lastIndex的值 console.log(reg.lastIndex) // 9 console.log(reg.exec(str)); // [ '2020', index: 14, input: 'chang2019cheng2020', groups: undefined ] // 虽然捕获的不是同一个字符串，但是正则是同一个，上一次正则处理的时候修改了它的lastIndex值， // 也会对下一次匹配的字符串产生影响 let str = 'chang2019cheng2020'; let reg = /\\d+/g; console.log(reg.exec(str)); // [ '2019', index: 5, input: 'chang2019cheng2020', groups: undefined ] console.log(reg.exec('20180809cheng2020')) // [ '2020', index: 13, input: '20180809cheng2020', groups: undefined ] RegExp.$1 浏览器中RegExp.$1只有一个，其他的操作也会覆盖这个值，所以没什么用 let str = 'chang2019cheng2020' let reg = /(\\d+)/g; console.log(reg.test(str)) // true console.log(RegExp.$1) // 2019 获取的是一个小分组匹配的内容，大正则匹配的内容无法获取 console.log(reg.test(str)) // true console.log(RegExp.$1) // 2020 console.log(reg.test(str)) // false console.log(RegExp.$1) // 2020 console.log(reg.test(str)) // true console.log(RegExp.$1) // 2019 遍历到最后又会从头开始遍历 String.replace() let str = 'chang2019chang2020' str = str.replace(/chang/g,'aaa') console.log(str) //aaa2019aaa2020 let str = 'chang{val:10}cheng{val:20}' str = str.replace(/\\{val:(\\d+)\\}/g,'aaa') console.log(str) //changaaachengaaa Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-12-31 14:06:34 "},"node/node.html":{"url":"node/node.html","title":"node基础语法","keywords":"","body":"node基础语法 特点 单线程非阻塞IO，这是由javaScript这门脚本语言的用途决定的 浏览器的ui线程和js的线程共用一个线程 webWorker并没有改变单线程的特点 1.完成受主线程的控制(附庸关系) 2.不能操作Dom 除了JS线程和UI线程之外的其他线程 浏览器事件触发线程 定时触发器线程 异步HTTP请求线程 同步和异步关注的是消息的通知方式 同步异步是由调用方决定，他来决定是马上给你答案，还是回头再给 阻塞非阻塞是由调用方来决定，在等待答案的过程，调用方可以干别的事 repl就是Node的窗口容器 .break 退出当前的代码编写块 .clear 清楚当前上下文 .save (.save num.log) 保存当前的代码生成文件 console console.time() console.timeEnd():用来计算代码的执行时间 console.time(\"time\") var i=0; while(i++ console.assert() 断言 TDD 测试驱动开发 BDD 行为驱动开发 // 断言 function sum(a,b){return a+b} console.assert(sum(1,2) == 4,'报错') console.dir():可以列出对象的解构 let a = {a:123,home:{name:'beijing'}} console.dir(a) console.trace():可以列出对象的解构 console.trace() global process console.log(process) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2019-11-22 17:52:55 "}}