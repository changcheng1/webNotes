{"./":{"url":"./","title":"Introduction","keywords":"","body":" 学习笔记 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-17 11:23:57 "},"web/es6/jiegou.html":{"url":"web/es6/jiegou.html","title":"解构赋值","keywords":"","body":" // 解构赋值 // 解构的方式都是根据key来实现 let [,age] = ['姓名','年龄']; console.log(age); // 年龄 // 用：号来重新命名 = 可以用来赋值默认值 let {name,age:age1,address=\"回龙观\"} = {name:'珠峰',age:10}; console.log(name,age1,address); // '珠峰',10,'回龙观' // 剩余运算符 只能用在最后一项 let [,...args] = ['珠峰',10,'回龙观']; // slice console.log(args); //[10,'回龙观'] // 对象的剩余运算符 let {name,...args} = {name:'珠峰',age:10}; console.log(args); // {age:10} // 可以使用圆括号的只有一种情况,赋值语句而不是声明语句 [(b)] = [3] ({p:(d)} = {}) [(parseInt.pop)] = [3] //变量名和属性名不一致的情况 const {foo:baz} = {foo:'aaa',bar:'ccc'} console.log(baz) // aaa // -------- // 实现一个深拷贝 递归拷贝 lodash =》cloneDeep let school = { name: \"珠峰\", age: 10, a: { b: 2 }, fn: () => {}, c: undefined, reg: /\\d+/ }; // 1) 怎么判断数据的类型 // typeof object Array // Object.prototype.toString.call() // instanceof 可以判断类型 判断是谁的实例 // constructor 构造函数 const deepClone = (value ,hash = new WeakMap) => { if(value == null) return value; // 排除掉null 和undefine 的情况 if(typeof value !== 'object') return value; // 这里包含了函数类型 if(value instanceof RegExp) return new RegExp(value); if(value instanceof Date) return new Date(value); // ..... // 拷贝的人可能是一个对象 或者是一个数组 (循环) for in let instance = new value.constructor; // 根据当前属性构造一个新的实例 if(hash.has(value)){ // 先去hash中查看一下是否存在过 ，如果存在就把以前拷贝的返回去 return hash.get(value); // 返回已经拷贝的结果 } hash.set(value,instance);// 没放过就放进去 // 用一个对象来记忆 for(let key in value){ // 一层 if(value.hasOwnProperty(key)){ // 将hash 继续向下传递 保证这次拷贝能拿到以前拷贝的结果 instance[key] = deepClone(value[key],hash); // 产生的就是一个新的拷贝后的结果 }// 过滤掉原型链上的属性 } return instance }; let obj = {a:1}; obj.b = obj; // 如果obj 已经被拷贝了一次 那下次 在用到obj的时候 直接返回就好了 不需要再次拷贝了 console.log(deepClone(obj)); let arr = [1,2,3,[4,5,6]] let newArr = deepClone(arr) newArr[3][2] = 100; console.log(arr); // set / map 也是不能放重复的项 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-19 11:13:10 "},"web/es6/array.html":{"url":"web/es6/array.html","title":"array","keywords":"","body":" { // 把一组数字转化为数组的方法 let arr = Array.of(3, 4, 7, 9, 11) console.log('arr=', arr) let empty = Array.of() console.log('empty', empty) } { // Array.from():可以将伪数组转化为真正的数组。 let p = document.querySelectorAll('p') let pArr = Array.from(p) pArr.forEach(function (item) { console.log(item.textContent) }) // Array.from():还有类似于map的作用 console.log(Array.from([1, 2, 3, 4, 5], (item) => { return item * 2 })) } { //Array.fill():对数组进行填充(填充内容,开始位置，结束位置-1) console.log('fill-7', [1, 'a', undefined].fill(7)) console.log('fill-7', [1, 2, 3, 4, 5, 6, 7].fill(7, 1, 3)) // [1, 7, 7, 4, 5, 6, 7] } { // Array.keys():数组进行遍历Index for (let index of [1, 2, 3, 4].keys()) { console.log('index', index) } // Array.values():数组进行遍历value for (let value of [1, 2, 3, 4].values()) { console.log('value', value) } // Array.entries():数组进行遍历value和Index for (let [index, value] of [1, 2, 3, 4, 5].entries()) { console.log('index', index, 'value', value) } } { // Array.copyWithin(替换的位置，从开始的位置读取的数) console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)) // [4,2,3,4,5] console.log([1, 2, 3, 4, 5].copyWithin(2, 1, 2)) // [1,2,3,4,5] } { //Array.find():返回符合条件的数组成员 console.log([1, 2, 3, 4, 5, 6].find((item) => { return item > 2 })) // 3 // Array.findIndex():返回符合条件的数组成员所在的key console.log([1, 2, 3, 4, 5, 6].findIndex((item) => { return item > 0 })) //3 } { //Array.includes():检测数组里面是否包含某个元素 console.log('number', [1, 2, NaN].includes(NaN)) // number true } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:41:41 "},"web/es6/class.html":{"url":"web/es6/class.html","title":"class","keywords":"","body":" // 类 // __proto__ 指向所属类的原型 // prototype 所有类都有一个prototype属性 // constructor prototype.constructor 每个类的原型上都有这个属性 // 继承公共属性prototype 继承实例上 class Animal { type = '哺乳类'; // 声明到实例上的 constructor(){ this.type = '哺乳类' } get a(){ // Object.defineProperty(Animal.protoype,a) return 1; // Animal.prototype.a = 1; } say(){ // 放到了原型上 // Animal.prototype.say console.log(this); } // 静态属性就是定义到类上的属性 es6中只有静态方法 static get flag(){ // es6的静态属性 return '动物' } } let animal = new Animal(); // 如果将类中的方法拿出来用必须绑定this 否则默认指向undefind Animal.flag // 动物 let say = animal.say.bind(animal) say(); // 静态方法在es6中也会被子类继承 class Animal{ static flag = 1; constructor(name){ this.name = name; this.type = '哺乳类' } say(){ console.log('say') } } // Tiger.__proto__ = Animal // call + Object.create() + Object.setPrototypeOf // 通过Object.defineProperty实现了 原型 + 静态方法属性的定义 class Tiger extends Animal{ constructor(name){ super(name); // 调用super Animal.call(tiger,name); // super 指代的是父类 // constructor中的super指代的问题 console.log(this) } static getAnimal(){ console.log(super.flag,'---'); // 这个super指代的是父类 } say(){ super.say(); // super 指向的是 父类的原型 } } let tiger = new Tiger('老虎'); tiger.say() // console.log(Tiger.getAnimal()); // static get / set super extends // new 的原理 function A(){ this.name = 1; this.age = 2; return {c:1} // 如果一个类返回了一个引用空间 那么实例将这个空间 } console.log(new A()) A.prototype.say = function(){ console.log('say') } function mockNew(A){ let obj = {} let returnVal = A.call(obj); if((typeof returnVal === 'object' && returnVal !== null) || typeof returnVal === 'function'){ return returnVal; } obj.__proto__ = A.prototype return obj; } let o = mockNew(A) // 1) 创建了一个一个对象,并且将对象传入到到函数中作为this // o.say(); console.log(o); Es5的类和Es6的区别 Es5的类函数可以直接调用，Es6的函数调用会报错，必须new Es5的类的方法是可以枚举的，Es6的方法不可枚举 class Pointer{ constructor(){ } say(){ console.log('say') } } console.log(Object.keys(Pointer.prototype)) // [] function Animal(){ } Animal.prototype.say = function(){ console.log('say') } let animal = new Animal() console.log(Object.keys(Animal.prototype)) // ['say'] Es5的类存在变量提升，ES6的类没有 new Foo() //Cannot access 'Foo' before initialization class Foo{} new Foo() function Foo(){} Es6类的静态方法，只能被定义的类调用，可以被继承 new.target可以返回new的那个构造函数，可以这个属性确定谁来调用，更重要的是子类继承父类，new.target会返回子类 function Foo(){ console.log(new.target == Foo) //true } let foo = new Foo() class Animal{ constructor(){ console.log(new.target == Dog) //true } } class Dog extends Animal{ } let dog = new Dog() Object.getPropertyOf():用来从子类上获取父类 Object.getPropertyOf(Dog) === Animal //true 7.父类的constructor中的this属性，子类是没有办法继承的，原型链可以 class Animal{ constructor(){ this.x = 3 }, print() { console.log(this.x); } } Animal.prototype.c = 1 class Dog extends Animal{ constructor(){ super() this.x = 9 console.log(super.a) //undefined console.log(super.c) // 1 }, m(){ super.print() } } let dog = new Dog() dog.m() // 9 8.super.print()虽然调用的是Animal.prototype.print，但是实际上执行的是super.print.call(this) 9.类的prototype和proto 子类的proto，指向父类 子类prototype的属性的proto属性，表示方法的继承，指向父类的prototype class A{} class B extends A{} B.__proto__ == A //true B.prototype.__proto__ == A.prototype //true 10.子类实例的proto属性的proto属性，指向父类实例的proto属性 var p1 = new Point(2, 3); var p2 = new ColorPoint(2, 3, 'red'); p2.__proto__.__proto__ === p1.__proto__ // true // 修改父类原型的方法 p2.__proto__.__proto__.printName = function () { console.log('Ha'); }; p1.printName() // \"Ha\" 11.extends可以继承原生构造函数 class myArray extends Array{ constructor(...args){ super(...args) } } let arr = new myArray('1') console.log(arr) //['1'] console.log(arr.length) // 1 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-18 16:01:39 "},"web/es6/const&let.html":{"url":"web/es6/const&let.html","title":"const & let","keywords":"","body":" // var let & const // es6 -> es5 babel // 1) 声明的变量默认声明到全局上，全局作用域 函数作用域 // {} 作用域+ let 实现一个作用域 // 2) 用var 声明的变量会导致变量提升 var function import // 用let声明的变量会绑定到当前作用域 暂存死区 // 3) var a = 1 var a = 2; 使用let 可以保证我的代码命名不重复 // 4) var 声明的变量可以更改 var a = 1 a =100 // 5) 自执行函数可以解决作用域问题 // 6) js 事件 不要用var // eslint for (let i = 0; i { console.log(i) //0,1,2,3,4,5,6,7,8,9 }); // 4ms }; // 解决 for (var i = 0; i { console.log(i) }); // 4ms })(i) //0,1,2,3,4,5,6,7,8,9 }; // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout // let & const 尽可能使用const 如果这个值需要改变 我们在更换let const obj = {}; obj.q = 1; // Assignment to constant variable. let a = 2; let a = 3; // Identifier 'a' has already been declared { console.log(a); var a = 1; } console.log(a); 1.let/const和{}会劫持当前的作用域 2.Es6的let和const不存在变量提升 a // Cannot access 'a' before initialization const a = 3 3.什么是暂时性死区,在let声明变量之前，该变量都是不可用的。 var temp = 3; if(true){ console.log(temp) //Cannot access 'temp' before initialization let temp = 2; } function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 4.let不允许重复声明 5.块级作用域中的函数声明 (function () { // 相当于 vat f = undefined if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } // f is not a function } f(); }()); const如果引用的地址是对象也可以修改 const a = {c:1} a.c = 3 console.log(a.c) // 3 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-18 16:45:43 "},"web/es6/decorators.html":{"url":"web/es6/decorators.html","title":"decorators","keywords":"","body":" { // 设置类的属性不能够修改 function get(target, name, descriptor) { descriptor.writable = false; return descriptor } class test { @get time() { return '2018-07-08' } } let Test = new test() // Test.time = function () { // return '设置修改属性不能修改' // } console.log(Test.time()) } { let name = function (target) { target.myName = '常成' } @name class getName {} console.log(getName.myName) } { let log = (type) => { return function (target, name, descriptor) { let src_method = descriptor.value; console.log('target:', target) console.log('name:', name) console.log('descriptor:', descriptor) descriptor.value = (...arg) => { src_method.apply(target, arg) console.log(`log{$type}`) } } } class AD { @log('show') show() { console.log('ad is show') } @log('click') click() { console.info('ad is click') } } let ad = new AD() ad.show() ad.click() } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:50:00 "},"web/es6/function.html":{"url":"web/es6/function.html","title":"function","keywords":"","body":" 箭头函数没有 this arguments prototype { // 函数设置默认值 function test(x, y = 'hello world') { console.log('默认值', x, y) } test('hello') test('hello', 'kill') } { // 函数的作用域 let x = 'test'; function test(x, y = x) { console.log('作用域', x, y) } test('kill') } { // rest参数 function test3(...arg) { for (let v of arg) { console.log('rest', v) } } test3(1, 2, 3, 4, 'a') } { // 解构 console.log(...[1, 2, 3, 4]) console.log('a', ...[1, 2, 3, 4]) } { // 箭头函数 let arrow = v => v * 2 let arrow2 = () => 5 console.log('arrow', arrow(3)) console.log(arrow2()) } { // 函数尾调用 function tail(x) { console.log('tail', x) } function fx(x) { return tail(x) } fx(123) } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-31 11:27:26 "},"web/es6/generator.html":{"url":"web/es6/generator.html","title":"generator","keywords":"","body":" { // genertaor基本定义 let tell = function* () { yield 'a'; yield 'b'; return 'c' }; let k = tell(); console.log(k.next()); console.log(k.next()); console.log(k.next()); console.log(k.next()); } { let obj = {}; obj[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; } for (let value of obj) { console.log('value', value); } } { let state = function* () { while (1) { yield 'A'; yield 'B'; yield 'C'; } } let status = state(); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); } // { // let state=async function (){ // while(1){ // await 'A'; // await 'B'; // await 'C'; // } // } // let status=state(); // console.log(status.next()); // console.log(status.next()); // console.log(status.next()); // console.log(status.next()); // console.log(status.next()); // } // { let draw = function (count) { //具体抽奖逻辑 console.info(`剩余${count}次`) } let residue = function* (count) { while (count > 0) { count--; yield draw(count); } } let star = residue(5); let btn = document.createElement('button'); btn.id = 'start'; btn.textContent = '抽奖'; document.body.appendChild(btn); document.getElementById('start').addEventListener('click', function () { star.next(); }, false) } { // 长轮询 let ajax = function* () { yield new Promise(function (resolve, reject) { setTimeout(function () { resolve({ code: 0 }) }, 200); }) } let pull = function () { let genertaor = ajax(); let step = genertaor.next(); step.value.then(function (d) { if (d.code != 0) { setTimeout(function () { console.info('wait'); pull() }, 1000); } else { console.info(d); } }) } pull(); } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:51:50 "},"web/es6/iterator.html":{"url":"web/es6/iterator.html","title":"iterator","keywords":"","body":" { let obj = 'helloworld' let map = obj[Symbol.iterator](); console.log('array:' + map.next()) console.log('array:' + map.next()) console.log('array:' + map.next()) } { var it = Iterator(['4', '5']) console.log(it.next()) console.log(it.next()) function Iterator(array) { var nextIndex = 0 return { next: function () { console.log(array) return nextIndex Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:52:15 "},"web/es6/module.html":{"url":"web/es6/module.html","title":"模块化","keywords":"","body":" import 语法只能放在最外层 导入的变量不能更改赋值 // Common.js模块输入的的是值的缓存，不存在动态更新 export var foo = 'bar'; setTimeout(() => foo = 'baz', 500); // 模块重命名 将lastName改成surname import { lastName as surname } from './profile.js'; // 引入的变量只能是只读，不能进行修改，如果是对象可以改写(不建议操作) import {a} from './1.js' a = 3 // 'a' is read-only // import具有变量提升的作用 foo() import {foo} from '1.js' // 整体加载 import * as cycle from '1.js' console.log(cycle.a) // export default 本身就是输出一个叫default的变量或者方法，可以自己改名 function add(x, y) { return x * y; } export {add as default}; // 等同于 // export default add; // app.js import { default as foo } from 'modules'; // 等同于 // import foo from 'modules'; Es6模块化与commonJs的差异 commonJs模块输出的是一个值得拷贝，Es6模块输出的是值得引用 commonJs模块是运行时加载，Es6模块是编译时输出接口 commonJs可以给模块中的值重新复制，Es6模块不能重新赋值 commonJs可以在js的任何位置中引入，import只能在js的顶部 commonJs模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载就返回第一次的运行结果 commonJs commonJs输出的是值的拷贝，模块内部的变化影响不到这个值，因为commonJs内部会缓存值 // 1.js var count = 3; function incCounter(){ count++ } module.exports = { count, incCounter } // main.js var mod = require('./1.js') console.log(mod.counter) // 3 mod.incCounter() console.log(mod.counter) // 3 Es6模块化（import） 遇到模块加载命令import，就会生成一个只读引用，等到脚本就真正执行的时候，再根据这个引用到模块当中去取值，原始的值改变了，import的值也会改变，因此Es6的值是动态引用，并且不会缓存值，模块内部的变量绑定所在模块 export var conut = 3; export function incCounter(){ conut ++ } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-15 15:01:09 "},"web/es6/Number&Math.html":{"url":"web/es6/Number&Math.html","title":"Number&Math","keywords":"","body":" { // Number.isFinite:检测一个数值是否是有限的 // Number.isNaN:检测一个数值是否是NaN console.log('15', Number.isFinite(15)) // true console.log('NaN', Number.isFinite(NaN)) // false console.log('1/0', Number.isFinite('true' / 0)) // false console.log('NaN', Number.isNaN(NaN)) // true console.log('0', Number.isNaN(0)) // false } { // Number.isInteger:判断一个数值是否为整数 console.log('25', Number.isInteger(25)) // true console.log('25.0', Number.isInteger(25.0)) // true console.log('25.1', Number.isInteger(25.1)) // false console.log('25', Number.isInteger('25')) // false } { // Math.trunc:去除一个数的小数部分，返回整数部分 console.log(4, 1, Math.trunc(4.1)) // 4 console.log(4.9, Math.trunc(4.9)) // 4 } { // Math.sign:判断一个数是正数，负数还是0，非数值会转换为数值 // 参数为正数，返回+1 // 参数为负数，返回-1 // 参数为0,返回0 // 参数为-0,返回-0 // 其他值返回NaN console.log('-5', Math.sign(-5)) // -1 console.log('0', Math.sign(0)) //0 console.log('5', Math.sign(5)) // 1 console.log('50', Math.sign('50')) // 1 console.log('foo', Math.sign('foo')) // NaN } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:53:19 "},"web/es6/object.html":{"url":"web/es6/object.html","title":"object","keywords":"","body":" { // 属性缩写 let o = 1; let k = 2; let es5 = { o: o, k: k } let es6 = { o, k } console.log(es5, es6) // 对象方法简写 let es5_method = { hello: function () { console.log('hello') } } let es6_method = { hello() { console.log('hello') } } es5_method.hello(), es6_method.hello() } { // 属性表达式 let a = 'b' let es5_obj = { a: 'c', b: 'c' } let es6_obj = { [a]: 'c' } console.log(es5_obj, es6_obj) } { // Object.is():比较两个值是否相等 console.log('字符串', Object.is('abc', 'abc'), 'abc' === 'abc') console.log('数组', Object.is([], []), [] === []) // 对象拷贝 console.log('拷贝', Object.assign({ a: 'a' }, { b: 'b' })) // 对象遍历 let test = { k: 123, 0: 456 } for (let [key, value] of Object.entries(test)) { console.log([key, value]) } } { // // 扩展运算符 // let {a,b,...c} = {a:'test',b:'kill',c:'ddd',d:'ccc'} // c={ // c:'ddd', // d:'ccc' // } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:53:52 "},"web/es6/promise.html":{"url":"web/es6/promise.html","title":"promise","keywords":"","body":" import { setTimeout } from \"timers\"; { // 定义函数 var ajax = function () { console.log('1') return new Promise(function (resolve, reject) { setTimeout(() => { resolve(\"\") }, 1000); }) } // 执行函数 ajax().then(function () { return new Promise((resolve, reject) => { console.log(\"2\") resolve(\"\") }) }).then(function () { // 返回一个promise实例 return new Promise((resolve, reject) => { console.log(\"3\") // resolve:表示允许下一步 resolve(\"\") }) }).then(function () { console.log(\"4\") }) } { let ajax = function (num) { return new Promise(function (resolve, reject) { if (num > 6) { resolve() } else { throw new Error(\"Num小于6\") } }) } ajax(7).then(function () { console.log(\"then\", \"大于6\") }).catch(function (err) { console.log(\"catch\", err) }) ajax(5).then(function () { console.log(\"then\", \"大于6\") }).catch(function (err) { // catch中err用于获取传参中的err console.log(\"catch\", err) }) } { let imgLoad = function (src) { return new Promise((resolve, reject) => { let img = new Image(); img.src = src; img.width = 300; img.height = 300; img.onload = function () { setTimeout(() => { // 传img进去 resolve(img); }, 1000) } img.onerror = function (err) { reject(err); } }) } let addImg = function (images) { images.forEach(img => { document.body.appendChild(img) }) } Promise.all([ imgLoad(\"http://img.zcool.cn/community/0142135541fe180000019ae9b8cf86.jpg@1280w_1l_2o_100sh.png\"), imgLoad(\"http://img1.imgtn.bdimg.com/it/u=3920398476,1501488149&fm=27&gp=0.jpg\"), imgLoad(\"http://img01.taopic.com/160909/240378-160ZZK14275.jpg\") ]).then(addImg) } { let imgLoad = function (src) { return new Promise((resolve, reject) => { let img = new Image(); img.src = src; img.width = 300; img.height = 300; img.onload = function () { setTimeout(() => { // 传img进去 resolve(img); }, 1000) } img.onerror = function (err) { reject(err); } }) } let addImg = function (img) { console.log(img) let p = document.createElement('p'); p.appendChild(img) document.body.appendChild(p) } // 返回promise率先完成的第一个结果 Promise.race([ imgLoad(\"http://img.zcool.cn/community/0142135541fe180000019ae9b8cf86.jpg@1280w_1l_2o_100sh.png\"), imgLoad(\"http://img1.imgtn.bdimg.com/it/u=3920398476,1501488149&fm=27&gp=0.jpg\"), imgLoad(\"http://img01.taopic.com/160909/240378-160ZZK14275.jpg\") ]).then(addImg) } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:54:13 "},"web/es6/proxy.html":{"url":"web/es6/proxy.html","title":"proxy","keywords":"","body":" // proxy 兼容性差 // 代理 我们可以创造一个代理 帮我们干某些事 let obj = { a:{a:2} } let handler = { // 只能代理当前这个对象 1层 get(target,key){ // 有13中属性 symbol 11种 // return target[key] if(typeof target[key] === 'object'){ return new Proxy(target[key],handler); // 如果是对象 就返回这个对象的代理 } return Reflect.get(target,key); }, set(target,key,value){ // 反射属性 // target[key] = value; if(key === 'length') return true; console.log('update'); return Reflect.set(target,key,value); } } let proxy = new Proxy(obj,handler) proxy.a.a = 100 console.log(obj.a.a); // 支持数组 可以直接更改数组 达到拦截的目的 // symbol 11 reflect 13种 // es6module的应用 // class // reduce // nodeh核心 } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 15:00:12 "},"web/es6/Reflect.html":{"url":"web/es6/Reflect.html","title":"Reflect","keywords":"","body":" // 未来object的方法部分会迁移到Reflect // 反射 Object.defineProperty // 里面有部分的对象的方法 放到 Reflect 功能基本一致 // Proxy 中能代理的方法 Reflect 都可以实现 // 1) get /set const obj = {}; Reflect.set(obj,'name','zf'); // obj.name = zf; console.log(Reflect.get(obj,'name')); // 2) has // 老的写法 console.log('a' in {a:1}); // 新的写法 console.log(Reflect.has({a:1},'a')); // 3)defineProperty // 把对象上的属性get set 都给重写了 const obj = {a:1} Object.freeze(obj); // 这个属性就能不能配置了 冻结freeze let flag = Reflect.defineProperty(obj,'a',{ value:100 }) console.log(flag); // 4)getOwnPropertyDescriptor const obj = {a:1}; console.log(Reflect.getOwnPropertyDescriptor(obj,'a')); // 5)ownKeys let obj = { a:1, [Symbol()]:1 }; console.log(Object.getOwnPropertyNames(obj)); console.log(Object.getOwnPropertySymbols(obj)); console.log(Reflect.ownKeys(obj)) // 6) Reflect.setPrototypeOf Reflect.getPrototypeOf // 7) 函数的apply方法 bind call apply的区别 改变this指向 const fn = function(a,b){ // apply 支持多个参数传参 console.log(this,a,b); } fn.apply = function(){ console.log('apply') } // 函数原型上的apply方法 让他执行 // call 的特点 1） 是改this指向 让函数执行 // Function.prototype.apply.call(fn,1,[2,3]); Reflect.apply(fn,1,[2,3]); // 用原型上的apply方法 class XXX{ constructor(name){ this.name = name } } let xxx = Reflect.construct(XXX,['zf']); console.log(xxx); // new Reflect.deleteProperty // delete obj.a 返回是否删除成功 let obj = {}; // 扩展不能添加属性 Reflect.preventExtensions(obj) obj.a = 1; console.log(Reflect.isExtensible(obj)); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 15:01:23 "},"web/es6/set&map.html":{"url":"web/es6/set&map.html","title":"set&map","keywords":"","body":" { // set中数据的唯一性 let list = new Set() list.add(1) list.add(2) list.add(1) console.log('list',list) //{1, 2} let arr = [1,2,3,4,'2']; let list2 = new Set(arr) console.log('unique',list2); // {1, 2, 3, 4, \"2\"} } { //list.has():判断set结构中是否包含 let arr = ['add','delete','clear','has']; let list = new Set(arr) console.log('has',list.has('add')); // has true console.log('delete',list.delete('add'),list); // delete true {\"delete\", \"clear\", \"has\"} list.clear(); // 清空set数据结构 console.log('list',list); // list {} } { // set数据遍历的方法 let arr = ['add','delete','clear','has']; let list = new Set(arr) for(let key of list.keys()){ console.log('keys','key') // keys key } for(let value of list.values()){ console.log('value',value) // value add value delete value clear value has } for(let [key,value] of list.entries()){ console.log('entries',key,value); // entries add add entries delete delete entries clear claer entries has has } list.forEach(function(item){console.log(item); // add delete clear has }) } { // 声明weakSeet数据结构 // weakSet的成员只能是对象 // weakSet不能被遍历 // weakSet的对象是弱引用，如果其他对象都不再引用该对象 // 那垃圾回收机制会自动回收该对象所占的内存 let weakList = new WeakSet(); let arg = {} weakList.add(arg) console.log(weakList); } { // map.get():获取map数据结构的值 let map = new Map() let arr = ['123'] map.set(arr,456) console.log('map',map,map.get(arr)) } { // 声明map的key和value的 let map = new Map([['a',123],['b',456]]) console.log('map args',map); console.log('size',map.size); console.log('delete',map.delete('a'),map); console.log('clear',map.clear(),map); } { // 声明weakMap的数据结构 let weakmap = new WeakMap() let o = {} weakmap.set(o,123) console.log(weakmap.get(o)); } { let map = new Map() // map.set() map.set('t','1') console.info('map.set()',map) // map的获取 console.log('map.get()',map.get('t')); // 遍历map的数据结构 for(let [key,value] of map.entries()){ console.log('map.entries()',value) } // map.has() console.log('map.has()',map.has('t')) // 获取map的长度 console.log('map.size',map.size); // map.delete() map.delete('t') // map.clear() map.clear() } // 优先使用map这种数据结构，考虑数据的唯一性，考虑set { //map,set,Object对比 let item = {t:1} let map = new Map() let set = new Set() let obj = {} // 增 map.set('t',1) set.add(item) obj['t'] = 1; console.log('map-set-obj',map,set,obj); // 查 console.log('map_exist',map.has('t')); console.log('set_exist',set.has(item)); console.log('map_exist','t' in obj); // 改 map.set('t',2) item.t = 2 obj['t'] = 2 console.log('map-set-obj-modify',map,set,obj); // 删 map.delete('t') set.delete(item) delete obj['t'] console.log('map-set-obj-delete',map,set,obj); } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-18 16:54:48 "},"web/es6/string&Method.html":{"url":"web/es6/string&Method.html","title":"string&Method","keywords":"","body":" { console.log('a','\\u0061') //a ,a // 因为表示法仅限于码点在\\u0000~\\uFFFF当中，超出只能通过双字节来表示 \\uD842\\uDFB7 console.log('s',`\\u20BB7`) // s ₻7 console.log('s',`\\u{20BB7}`) // s 𠮷 } { // js中字符已UTF-16格式存储，每个字符固定两个字节，对于那些 // 需要四个字符存储的字符，js会认为是两个字符 let s = '𠮷' ; console.log('length',s.length) // length 2 console.log('0',s.charAt(0)) // 0 � console.log('1',s.charAt(1)) // 1 � console.log('at0',s.charCodeAt(0)) // at0 55362 console.log('at1',s.charCodeAt(1)) // at1 57271 let s1 = '𠮷a'; console.log('length',s1.length); //3 console.log('code0',s1.codePointAt(0)) //code0 134071 console.log('code0',s1.codePointAt(0).toString(16)) //code0 20bb7 console.log('code1',s1.codePointAt(1)) //code1 57271 console.log('code2',s1.codePointAt(2)) //code2 97 } { // 使用该方法从码点返回对应的字符串 console.log(String.fromCharCode('0x20bb7')) //ஷ // 相比上一个方法可以识别大于0xFFFF的码点 console.log(String.fromCodePoint(\"0x20bb7\")); //𠮷 } { let str = '\\u{20bb7}abc' for (let index = 0; index Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 11:10:43 "},"web/es6/symbol.html":{"url":"web/es6/symbol.html","title":"symbol","keywords":"","body":" // 数据类型 string number boolean null undefined // Symbol 独一无二 // 用作常量 const s1 = Symbol(\"zf\"); // number or string const s2 = Symbol(\"zf\"); console.log(s1 === s2); // 属性私有化 let s1 = Symbol.for(\"zf\"); let s2 = Symbol.for(\"zf\"); // 如果symbol已经有值了 就将这个值返回即可 console.log(s1 === s2); console.log(Symbol.keyFor(s2)); let obj = { [s1]: 1 // es6写法 []含义是将s1 结果取出来作为key }; console.log(obj[s1]); // 不能使用.运算符 // 元编程 可以改变js源代码的功能 改变js原有的功能 // instanceof // 可以判断某个人是否是谁的实例 let o = { name: 1 }; // Symbol.iterator 在我迭代的时候 默认就会调用此方法 let obj = { // Object.defineproperty [Symbol.hasInstance]() { return \"name\" in o; } }; console.log(o instanceof obj); let obj = { [Symbol.toPrimitive](value) { console.log(value); return \"hello\"; }, a: 1 }; // valueOf toString console.log(obj * 1); // toString const obj = { get [Symbol.toStringTag]() { return \"123\"; } }; // Object.prototype.toString console.log(obj.toString()); // [object 123] // 衍生对象 class MyArray extends Array { constructor(...args) { super(...args); } static get [Symbol.species]() { return Array; // 控制衍生对象的类的构造函数 } } let myarr = new MyArray(1, 2, 3); let newArr = myarr.map(item => item * 2); // 衍生出来的结果是当前的实例 // instanceof 原理 .__proto__.__proto__ console.log(newArr instanceof MyArray); // split replace match search // with 我可以通过with 直接拿到with中的属性 // 我们可以声明一些属性 不在with中使用 console.log(Array.prototype[Symbol.unscopables]) with (Array.prototype) { fill(1,2,3) } class My{ eat(){} get [Symbol.unscopables](){ return {eat:true}; } } with(My.prototype){ console.log(eat); } let arr = [1,2,3]; arr[Symbol.isConcatSpreadable] = false; console.log(arr.concat(4,5,6)); // Symbol 11 reflect 13 } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 16:42:23 "},"web/es6/defineProperty.html":{"url":"web/es6/defineProperty.html","title":"defineProperty","keywords":"","body":" // Object.defineProperty getter setter let obj = { _a:'', get a(){ // todo ... return this._a }, set a(value){ this._a = value } } obj.a = 100; console.log(obj.a); // 需要借用一个第三方变量来中转 // vue中数据劫持 给每个对象都添加一个 getter和setter 当值变化可以 可以实现更新视图的功能 let obj = {} let val = ''; Object.defineProperty(obj,'a',{ configurable:true, // 是否可删除 // writable:true, // 是否可写, enumerable:true, // for in 原型上的方法 get(){ return val }, set(value){ val = value; } // 默认设置的值是不可枚举的 }) delete obj.a console.log(obj); let obj = { a: 1, b: 2, }; // value 源码 function observer(obj) { // 缺陷就是无法监控数组的变化 if (typeof obj !== \"object\" || obj == null) { return; } for (let key in obj) { // 因为defineProperty 需要一个公共的值去修改 defineReactive(obj, key, obj[key]); } } let updateView = () => { // 更新方法 console.log(\"更新\"); }; // obj => {a:1,b:2} key=> a / b value = 1/2 function defineReactive(obj, key, value) { // Object.defineProperty observer(value); // 递归增加getter和setter Object.defineProperty(obj, key, { get() { return value; }, set(val) { updateView(); value = val; } }); } observer(obj); obj.a.a = 100; console.log(obj.a); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 11:21:32 "},"node/node.html":{"url":"node/node.html","title":"简介","keywords":"","body":" node 基础语法 常用：中间层 服务端渲染 脚本 特点 单线程非阻塞 IO，这是由 javaScript 这门脚本语言的用途决定的 浏览器的 ui 线程和 js 的线程共用一个线程 webWorker 并没有改变单线程的特点 1.完成受主线程的控制(附庸关系) 2.不能操作 Dom 除了 JS 线程和 UI 线程之外的其他线程 浏览器事件触发线程 定时触发器线程 异步 HTTP 请求线程 进程和线程的区别 同步和异步关注的是消息的通知方式 同步异步是由调用方决定，他来决定是马上给你答案，还是回头再给 阻塞非阻塞是由调用方来决定，在等待答案的过程，调用方可以干别的事 repl 就是 Node 的窗口容器 .break 退出当前的代码编写块 .clear 清楚当前上下文 .save (.save num.log) 保存当前的代码生成文件 console console.time() console.timeEnd():用来计算代码的执行时间 console.time(\"time\") var i=0; while(i++ console.assert() 断言 TDD 测试驱动开发 BDD 行为驱动开发 // 断言 function sum(a,b){return a+b} console.assert(sum(1,2) == 4,'报错') console.dir():可以列出对象的解构 let a = {a:123,home:{name:'beijing'}} console.dir(a) console.trace():可以列出对象的解构 console.trace() global process console.log(process) fs 模块 const fs = require('fs') // 判断文件是否存在，不存在则抛出异常 fs.accessSync('./1.js') path 模块 const path = require('path'); // __dirname：获取当前的路径 // /Users/changcheng/Downloads/test console.log(__dirname) // path.resolve()：获取当前文件的绝对路径 // /Users/changcheng/Downloads/test/1.js console.log(path.resolve(__dirname, '1.js')) // path.join():拼接路径 // /Users/changcheng/Downloads/test/bar/1.js console.log(path.join(__dirname, '/bar/1.js')) // path.extname():获取文件后缀 // .js console.log(path.extname('1.js')) // path.basename():路径过滤 // 1. console.log(path.basename('1.js', 'js')) // path.dirname():取当前路径的父路径 // /Users/changcheng/Downloads console.log(path.dirname(__dirname)) vm 虚拟机模块 // error b is not defined const vm = require('vm') let b = 1; vm.runInThisContext(`console.log(b)`) require 原理 // 路径模块 const path = require('path'); // 文件模块 const fs = require('fs'); // 沙箱 const vm = require('vm'); function Module(absPath){ this.id = absPath; this.exports = {}; } const wrapper = [ // module 和 exports 是什么关系? '(function(exports,module,require){', '})' ] Module.prototype.load = function(){ let script = fs.readFileSync(this.id,'utf8'); let fnStr = wrapper[0] + script + wrapper[1]; let fn = vm.runInThisContext(fnStr); fn(this.exports,this,req); // 让拼出的函数执行 } function req(file){ // ./a // 1) 把当前这个文件读取出来 把相对路径转化成绝对路径 let absPath = path.resolve(__dirname,file); // 加载一个模块 模块就是要有一个exports属性 // 2) 创建一个模块 let module = new Module(absPath); // 创建了一个模块 // 3) 加载模块 module.load(); return module.exports } let a = req('./a.js'); console.log(a); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 11:05:11 "},"node/":{"url":"node/","title":"常用架构","keywords":"","body":" koa2 基础架构 koa-generator 异步库 npm install -g koa-generator 安装 koa2 模板 koa2 -e name koa2 项目所需插件 cross-env node 本地环境变量 安装 mysql 版本 5.7.23 安装 mysqlworkbench 可视化工具 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-11 15:49:11 "},"node/linux.html":{"url":"node/linux.html","title":"Linux","keywords":"","body":" 连接远程服务器 ssh -p 22 root@122.51.207.237 查找某个插件的位置 which ${nginx} 立刻杀死某个进程 ps -ef | grep node kill -9 ${进程id} 上传文件 cp -p 22 /Users/changcheng/Downloads/webNotes/_book.zip root@122.51.207.237:/usr/ linux 设置免密登录 客户端生成公钥和私钥，服务器生成公钥和私钥，交换各自的公钥，私钥加密公钥解密(Https的非对称加密) 1.设置本地秘钥 ssh-keygen -t rsa 2.开始ssh代理 eval \"$(ssh-agent -s)\" ssh-add ~/.ssh/id_rsa 3.把本地服务公钥上传到服务器 // 复制本地公钥 cat ~/.ssh/id_rsa.pub // 粘贴服务器文件夹 vi ~/.ssh/authorized_keys //设置权限 chmod 600 ~/.ssh/authorized_keys //重启服务器 systemctl restart sshd 安装软件 // 安装git yum -y install git curl wget // 安装cnpm，切换源 npm i cnpm -g pm2常用命令 pm2 start server.js --name \"blog\" pm2 list nginx安装 https://www.runoob.com/linux/nginx-install-setup.html 常用命令 // 启动nginx nginx // 关闭nginx nginx -s stop // 重读配置文件 nginx -s load Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-11 15:49:17 "},"node/mysql.html":{"url":"node/mysql.html","title":"mysql","keywords":"","body":"mySql mySql常用命令 // 查看所有的数据库 show databases; // 查看某个数据库 use databaseName; // 查询某个表 select * from tableName; // 查看users表的某几个字段 select username,nickname from users; // 往user表中添加数据(password是关键词) insert into users(username,`password`,nickname)values('zhangsan','123','张三'); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"node/redis.html":{"url":"node/redis.html","title":"redis","keywords":"","body":"redis基础 安装 // 启动redis服务 redis-server; // redis命令行操作 redis-cli; // 设置/修改值 set name 'changcheng' // 获取值 get name // 获取所有的key keys * // node安装redis插件 npm i redis -D Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"node/token.html":{"url":"node/token.html","title":"tooken/session/cookie","keywords":"","body":" tooken/session/cookie的区别 jwt vs session // 引入koa-jwt插件 const jwtKoa = require('koa-jwt') const jwt = require('jsonwebtoken') const verify = util.promisify(jwt.verify) // 设置加密算法的秘钥以及不校验的登录接口 app.use(jwtKoa({ secret:'secret' }).unless({ path: [/^\\/users\\/login/] })) // 登录接口返回token，有效时间一小时，由客户端进行存储 router.post('/login', async (ctx, next)=> { let SECRET = 'secret' let token = jwt.sign('result',SECRET, {expiresIn:'1h'}) } ctx.body = { errCode:0, data:token } } }) // 获取请求头中的token解密就是用户的信息 router.get('/getUserInfo', async (ctx, next)=> { const token = ctx.header.authorization try{ const payload = await verify(token.split(' ')[1],SECRET) ctx.body = { errno:0, userInfo:payload } }catch(err){ console.log('err',err) ctx.body = { errno:1, masg : 'verify token failed' } } }) 为了解决：登录&存储登录用户的信息 jwt用户信息加密存储在客户端，不依赖cookie，可跨域 session用户信息存储在服务端，依赖cookie，默认不可跨域 一般情况下，两者都能满足，大型系统中两者可共用 jwt更适合服务多的节点，跨域多的系统 session更适合统一的web服务，server要严格管理用户信息 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-02 16:02:19 "},"http/1.html":{"url":"http/1.html","title":"1.概述","keywords":"","body":" Http 协议 一、概述 1.计算机网络体系结构分层 2.TCP/IP 通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下： 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。 如下图所示： 在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP/1.1 版本）展开。 HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP 是客户端浏览器或其他程序与 Web 服务器之间的应用层通信协议。在 Internet 上的 Web 服务器上存放的都是超文本信息，客户机需要通过 HTTP 协议传输所要访问的超文本信息。HTTP 包含命令和传输信息，不仅可用于 Web 访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。 我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个 Internet 地址。当你在浏览器的地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将 Web 服务器上站点的网页代码提取出来，并翻译成漂亮的网页。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:15:31 "},"http/2.html":{"url":"http/2.html","title":"2.Http 工作过程","keywords":"","body":" 二、HTTP 工作过程 HTTP 通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列 7 个步骤： 1.建立 TCP 连接 在 HTTP 工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80； 2.客户端向服务器发送请求命令 一旦建立了 TCP 连接，客户端就会向服务器发送请求命令；例如：GET/sample/hello.jsp HTTP/1.1 3.客户端发送请求头信息 客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送； 4.服务器应答 客户端向服务器发出请求后，服务器会客户端返回响应； 例如： HTTP/1.1 200 OK 响应的第一部分是协议的版本号和响应状态码 5.服务器返回响应头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档； 6.服务器向客户端发送数据 服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据； 7.服务器关闭 TCP 连接 一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:25:40 "},"http/3.html":{"url":"http/3.html","title":"3.Http 协议基础","keywords":"","body":" 三、HTTP 协议基础 1.通过请求和响应的交换达成通信 应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。 换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。 2.HTTP 是不保存状态的协议 HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。 可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。 3.使用 Cookie 的状态管理 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 4.请求 URI 定位资源 HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。 5.告知服务器意图的 HTTP 方法（HTTP/1.1） 6.持久连接 HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。 其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。 7.管线化 持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-07 10:18:06 "},"http/4.html":{"url":"http/4.html","title":"4.Http 报文结构","keywords":"","body":" 四、HTTP 协议报文结构 1.HTTP 报文 用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 2.HTTP 报文结构 HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下： 2.1 请求报文结构 请求报文的首部内容由以下数据组成： 请求行 —— 包含用于请求的方法、请求 URI 和 HTTP 版本。 首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及 RFC 里未定义的首部如 Cookie 等） 请求报文的示例，如下： 2.2 响应报文结构 响应报文的首部内容由以下数据组成： 状态行 —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。 首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及 RFC 里未定义的首部如 Cookie 等） 响应报文的示例，如下： Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:16:07 "},"http/5.html":{"url":"http/5.html","title":"5.Http 报文首部之请求行、状态行","keywords":"","body":" 五、HTTP 报文首部之请求行、状态行 1.请求行 举个栗子，下面是一个 HTTP 请求的报文： GET /index.htm HTTP/1.1 Host: sample.com 其中，下面的这行就是请求行， GET /index.htm HTTP/1.1 开头的 GET 表示请求访问服务器的类型，称为方法； 随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI； 最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。 综合来看，大意是请求访问某台 HTTP 服务器上的 /index.htm 页面资源。 2.状态行 同样举个栗子，下面是一个 HTTP 响应的报文： HTTP/1.1 200 OK Date: Mon, 10 Jul 2017 15:50:06 GMT Content-Length: 256 Content-Type: text/html ... 其中，下面的这行就是状态行， HTTP/1.1 200 OK 开头的 HTTP/1.1 表示服务器对应的 HTTP 版本； 紧挨着的 200 OK 表示请求的处理结果的状态码和原因短语。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:27:49 "},"http/6.html":{"url":"http/6.html","title":"6.Http 报文首部字段","keywords":"","body":" 六、HTTP 报文首部之首部字段（重点分析） 1.首部字段概述 先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。 在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。 2.首部字段结构 HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。 另外，字段值对应单个 HTTP 首部字段可以有多个值。 当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。 首部字段名 冒号 字段值 Content-Type ： text/html Keep-Alive ： timeout=30, max=120 3.首部字段类型 首部字段根据实际用途被分为以下 4 种类型： 类型 描述 通用首部字段 请求报文和响应报文两方都会使用的首部 请求首部字段 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息 响应首部字段 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。 4.通用首部字段（HTTP/1.1） 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐挑首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 4.1 Cache-Control 通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。 4.1.1 可用的指令一览 可用的指令按请求和响应分类如下： 缓存请求指令 指令 参数 说明 no-cache 无 强制向服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [秒] 必需 响应的最大 Age 值 max-stale( =[秒]) 可省略 接收已过期的响应 min-fresh = [秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension - 新指令标记（token） 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age = [秒] 必需 响应的最大 Age 值 s-maxage = [秒] 必需 公共缓存服务器响应的最大 Age 值 cache-extension - 新指令标记（token） 4.1.2 表示能否缓存的指令 public 指令 Cache-Control: public 当指定使用 public 指令时，则明确表明其他用户也可利用缓存。 private 指令 Cache-Control: private 当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。 no-cache 指令 Cache-Control: no-cache 使用 no-cache 指令是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。 如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。 Cache-Control: no-cache=Location 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。 no-store 指令 Cache-Control: no-store 当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。 注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。 4.1.3 指定缓存期限和认证的指令 s-maxage 指令 Cache-Control: s-maxage=604800（单位：秒） s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。 max-age 指令 Cache-Control: max-age=604800（单位：秒） 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为 0，那么缓存服务器通常需要将请求转发给源服务器。 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。 应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。 min-fresh 指令 Cache-Control: min-fresh=60（单位：秒） min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。 max-stale 指令 Cache-Control: max-stale=3600（单位：秒） 使用 max-stale 可指示缓存资源，即使过期也照常接收。 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。 only-if-cached 指令 Cache-Control: only-if-cached 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。 must-revalidate 指令 Cache-Control: must-revalidate 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。 proxy-revalidate 指令 Cache-Control: proxy-revalidate proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。 no-transform 指令 Cache-Control: no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。 4.1.4 Cache-Control 扩展 Cache-Control: private, community=\"UCI\" 通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。 4.2 Connection Connection 首部字段具备以下两个作用： 控制不再转发的首部字段 Connection: Upgrade 在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即 Hop-by-hop 首部）。 管理持久连接 Connection: close HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。 Connection: Keep-Alive HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。 4.3 Date 表明创建 HTTP 报文的日期和时间。 Date: Mon, 10 Jul 2017 15:50:06 GMT HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。 4.4 Pragma Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。 Pragma: no-cache 该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。 所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段： Cache-Control: no-cache Pragma: no-cache 4.5 Trailer Trailer: Expires 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。 4.6 Transfer-Encoding Transfer-Encoding: chunked 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。 4.7 Upgrade Upgrade: TSL/1.0 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 4.8 Via Via: 1.1 a1.sample.com(Squid/2.7) 为了追踪客户端和服务器端之间的请求和响应报文的传输路径。 报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。 首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 4.9 Warning 该首部字段通常会告知用户一些与缓存相关的问题的警告。 Warning 首部字段的格式如下 Warning：[警告码][警告的主机:端口号] \"[警告内容]\"([日期时间]) --> 最后的日期时间可省略。 HTTP/1.1 中定义了 7 种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。 警告码 警告内容 说明 110 Response is stale(响应已过期) 代理返回已过期的资源 111 Revalidation failed(再验证失败) 代理再验证资源有效性时失败（服务器无法到达等原因） 112 Disconnection operation(断开连接操作) 代理与互联网连接被故意切断 113 Heuristic expiration(试探性过期) 响应的试用期超过 24 小时(有效缓存的设定时间大于 24 小时的情况下) 199 Miscellaneous warning(杂项警告) 任意的警告内容 214 Transformation applied(使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning(持久杂项警告) 任意的警告内容 5.请求首部字段（HTTP/1.1） 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Macth 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间(与 If-Modified-Since 相反) Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 5.1 Accept Accept: text/html, application/xhtml+xml, application/xml; q=0.5 Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。 若想要给显示的媒体类型增加优先级，则使用 q=[数值] 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。 5.2 Accept-Charset Accept-Charset: iso-8859-5, unicode-1-1; q=0.8 Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 q=[数值] 来表示相对优先级。 5.3 Accept-Encoding Accept-Encoding: gzip, deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 q=[数值] 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。 5.4 Accept-Language Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3 告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 q=[数值] 来表示相对优先级。 5.5 Authorization Authorization: Basic ldfKDHKfkDdasSAEdasd== 告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。 5.6 Expect Expect: 100-continue 告知服务器客户端期望出现的某种特定行为。 5.7 From From: Deeson_Woo@163.com 告知服务器使用用户代理的电子邮件地址。 5.8 Host Host: www.jianshu.com 告知服务器，请求的资源所处的互联网主机和端口号。 Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。 若服务器未设定主机名，那直接发送一个空值即可 Host: 。 5.9 If-Match 形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。 If-Match: \"123456\" 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。 服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。 还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。 5.10 If-Modified-Since If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT 首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。 它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。 5.11 If-None-Match If-None-Match: \"123456\" 首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。 5.12 If-Range If-Range: \"123456\" 首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。 下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。 5.13 If-Unmodified-Since If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。 5.14 Max-Forwards Max-Forwards: 10 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。 5.15 Proxy-Authorization Proxy-Authorization: Basic dGlwOjkpNLAGfFY5 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。 5.16 Range Range: bytes=5001-10000 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。 5.17 Referer Referer: http://www.sample.com/index.html 首部字段 Referer 会告知服务器请求的原始资源的 URI。 5.18 TE TE: gzip, deflate; q=0.5 首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。 首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers 5.19 User-Agent User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。 由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。 6. 响应首部字段（HTTP/1.1） 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 6.1 Accept-Ranges Accept-Ranges: bytes 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。 6.2 Age Age: 1200 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。 6.3 ETag ETag: \"usagi-1234\" 首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。 另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。 ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： ETag: W/\"usagi-1234\"。 6.4 Location Location: http://www.sample.com/sample.html 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。 6.5 Proxy-Authenticate Proxy-Authenticate: Basic realm=\"Usagidesign Auth\" 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。 6.6 Retry-After Retry-After: 180 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。 6.7 Server Server: Apache/2.2.6 (Unix) PHP/5.2.5 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。 6.8 Vary Vary: Accept-Language 首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。 6.9 WWW-Authenticate WWW-Authenticate: Basic realm=\"Usagidesign Auth\" 首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。 7. 实体首部字段（HTTP/1.1） 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 7.1 Allow Allow: GET, HEAD 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。 当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。 7.2 Content-Encoding Content-Encoding: gzip 首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。 主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。 7.3 Content-Language Content-Language: zh-CN 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。 7.4 Content-Length Content-Length: 15000 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。 7.5 Content-Location Content-Location: http://www.sample.com/index.html 首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。 7.6 Content-MD5 Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY== 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。 7.7 Content-Range Content-Range: bytes 5001-10000/10000 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。 7.8 Content-Type Content-Type: text/html; charset=UTF-8 首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。 7.9 Expires Expires: Mon, 10 Jul 2017 15:50:06 GMT 首部字段 Expires 会将资源失效的日期告知客户端。 缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。 7.10 Last-Modified Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT 首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。 8. 为 Cookie 服务的首部字段 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的 Cookie 信息 响应首部字段 Cookie 服务器接收到的 Cookie 信息 请求首部字段 8.1 Set-Cookie Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/; 下面的表格列举了 Set-Cookie 的字段值。 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 8.1.1 expires 属性 Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。 当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。 另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。 8.1.2 path 属性 Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。 8.1.3 domain 属性 通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie 因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。 8.1.4 secure 属性 Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。 8.1.5 HttpOnly 属性 Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。 通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。 8.2 Cookie Cookie: status=enable 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。 9. 其他首部字段 HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。 以下是最为常用的首部字段。 9. 其他首部字段 HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。 以下是最为常用的首部字段。 9.1 X-Frame-Options X-Frame-Options: DENY 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值： DENY：拒绝 SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 http://sample.com/sample.html 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com等其他域名的页面就不行了） 9.2 X-XSS-Protection X-XSS-Protection: 1 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下: 0 ：将 XSS 过滤设置成无效状态 1 ：将 XSS 过滤设置成有效状态 9.3 DNT DNT: 1 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下： 0 ：同意被追踪 1 ：拒绝被追踪 9.4 P3P P3P: CP=\"CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND 首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。 要进行 P3P 的设定，需按以下操作步骤进行： 步骤 1：创建 P3P 隐私 步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml 步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:47:15 "},"http/7.html":{"url":"http/7.html","title":"7.Http 相应状态码","keywords":"","body":" 七、HTTP 响应状态码（重点分析） 1. 状态码概述 HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。 HTTP 状态码如 200 OK ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。 不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK。 2. 状态码类别 状态码 类别 原因短语 1xx Informational(信息性状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。 3. 常用状态码解析 HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。 3.1 200 OK 表示从客户端发来的请求在服务器端被正常处理了。 3.2 204 No Content 代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。 一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。 3.3 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。 3.4 301 Moved Permanently 永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 3.5 302 Found 临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 Found 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。 3.6 303 See Other 表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 See Other 和 302 Found 状态码有着相同的功能，但 303 See Other 状态码明确表示客户端应采用 GET 方法获取资源，这点与 302 Found 状态码有区别。 3.7 304 Not Modified 表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。 304 Not Modified状态码返回时，不包含任何响应的主体部分。 304 Not Modified虽然被划分到 3xx 类别中，但和重定向没有关系。 3.8 307 Temporary Redirect 临时重定向。该状态码与 302 Found 有着相同的含义。 3.9 400 Bad Request 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 另外，浏览器会像 200 OK 一样对待该状态码。 3.10 401 Unauthorized 表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。 另外，若之前已进行过 1 次请求，则表示用户认证失败。 返回含有 401 Unauthorized 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。 3.11 403 Forbidden 表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。 3.12 404 Not Found 表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。 3.13 500 Internal Server Error 表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。 3.14 503 Service Unavailable 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:48:25 "},"http/8.html":{"url":"http/8.html","title":"8.Http 报文实体","keywords":"","body":" 八、HTTP 报文实体 1.Http 报文实体概述 大家请仔细看看上面示例中，各个组成部分对应的内容。 接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。 报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。） 我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 2.内容编码 HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。 这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。 内容编码类型： 编码方式 类别描述 gzip 表明实体采用 GNU zip 编码 compress 表明实体采用 Unix 的文件压缩程序 deflate 表明实体采用 zlib 的格式压缩的 identity 表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式 3.传输编码 内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。 传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。 4.分块编码 分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。 分块编码与持久连接 若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。 分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。 来看看一个分块编码的报文示例： 5.多部分媒体类型 MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。 相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。 多部分对象集合包含的对象如下： multipart/form-data：在 Web 表单文件上传时使用。 multipart/byteranges：状态码 206 Partial Content 响应报文包含了多个范围的内容时使用。 6. 范围请求 假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。 有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如： GET /bigfile.html HTTP/1.1 Host: www.sample.com Range: bytes=20224- ··· 上面示例中，客户端请求的是文档开头 20224 字节之后的部分 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-28 16:51:28 "},"http/9.html":{"url":"http/9.html","title":"9.与 Http 协作的 web 服务器","keywords":"","body":" 九、与 HTTP 协作的 Web 服务器 HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：代理、缓存、网关、隧道、Agent 代理。 1.代理 HTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。 出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。 2.缓存 浏览器第一次请求： 浏览器再次请求： Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。 缓存的分类 （1）强缓存 不会向服务器发送请求，直接从缓存中读取数据，在 chrome 浏览器当中的 netWork 中能看到返回码是 200 1) 强缓存 Expires: Tue, 13 Aug 2019 08:23:24 GMT // response header里的过期时间，如果在这个时间内，则命中强缓存 Cache-Control: Cache-Control:max-age=3600 //60分钟内再次请求该资源就会命中强缓存 Cache-Control:no-cache //不使用本地缓存，需使用协商缓存 no-store //禁止浏览器缓存数据，每次用户请求资源，都会向服务器发送一个请求 public //可以被所有用户缓存 private//只能被终端的浏览器缓存，不允许cdn等缓存服务器缓存 // 如果两个标识符都有，按照最后一个为准 （2）协商缓存 向服务器发送请求，服务器会根据请求头中的参数来判断是否命中协商缓存，如果命中，则返回 304 的状态并带上新的 response header 通知浏览器从缓存中读取资源 1) 协商缓存 Last-Modified:Tue, 13 Aug 2019 08:23:24 GMT //标识该资源最后修改的时间 Etag：hash值 //告诉浏览器此文件在服务器的唯一标识 3.网关 网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。 4. 隧道 隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。 HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。 5. Agent 代理 Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-30 10:33:43 "},"web/dom.html":{"url":"web/dom.html","title":"Dom","keywords":"","body":"常见的 dom 操作 操作 dom 的属性和方法 getElementById 上下文只能是 document(只有 document 这个实例的原型链上才能找到，其他实例找不到) ID 重复获取第一个 getElementsByTagName 获取上下文当中，所有子子孙孙的中标签叫 xx 的元素 getElementsByClassName 上下文只能是 document querySelector 返回匹配的一个元素，没有返回 Null querySelectorAll 返回符合条件的 nodeList 集合 document.documentElement 获取整个页面 html 结构 document.body document.heady 描述节点和节点之间关系的属性      nodeType    nodeName     nodeValue 元素节点    1      大写标签名     null 文本节点   3      #text       文本内容 注释节点   8      #comment     注释内容 文档节点   9      #document     null childNodes:所有子节点 children:所有元素节点 parentNode:父节点 previousSibling/previousElementSibling:前一个节点/前一个元素节点 nextSibling/nextElementSibling:下一个节点/下一个元素节点 firstChild/firstElementChild:第一个节点/第一个元素接地那 lastChild/lastElementChild:最后一个节点/最后一个元素节点 动态操作 Dom document.createElement:创建一个 dom 节点 document.createElement('button') createDocumentFragment:创建一个虚拟节点对象 var d=document.createDocumentFragment(); d.appendChild(document.getElementsByTagName(\"LI\")[0]); d.childNodes[0].childNodes[0].nodeValue=\"Milk\"; document.getElementsByTagName(\"UL\")[0].appendChild(d); appendChild 和 append 的区别 appendChild 不仅可以传节点也可以传入字符串，append 只能传入节点 appendChild:添加一个子元素 var node=document.getElementById(\"myList2\").lastChild; document.getElementById(\"myList1\").appendChild(node); insertBefore:在...之前插入一个元素 document.getElementById(\"myList\").insertBefore(newItem,existingItem); cloneNode(true/false) true:复制当前所有的子孙节点 false:只复制当前的节点 var node=document.getElementById(\"myList2\").lastChild.cloneNode(true); document.getElementById(\"myList1\").appendChild(node); removeChild:移除一个节点 var list=document.getElementById(\"myList\"); list.removeChild(list.childNodes[0]); set/get/removeAttribute setAttribute:设置属性 document.getElementsByTagName(\"INPUT\")[0].setAttribute(\"type\",\"button\"); getAttribute:获取属性 document.getElementsByTagName(\"a\")[0].getAttribute(\"target\"); removeAttribute:移除属性 document.getElementsByTagName(\"H1\")[0].removeAttribute(\"style\"); dom.style.xxx = xxx xxx.stye.xxx :获取行内样式 xxx.className = '' :设置 className 的名称 xxx.onClick = function(){}:设置点击事件 JS 盒子模型属性 在 js 中通过相关的属性可以获取(设置)元素的样式信息，这些属性就是盒子模型的属性 client(left/width/height) 1.clientWidth && clientHeight:获取可视区域的宽高(内容的宽高+padding 的宽高)，不算内容溢出。 2.clientleft && clientTop:获取(左/上)边框的宽度 3.document.documentElement.clientWidth/clientHeight:获取当前屏幕的可视宽度/高度,随着拉伸而改变 4.document.body.clientWidth/clientHeight:不会随拉伸而改变 offset(top/left/width/height/parent) 1.offsetWidth && offsetHeight:在 client 的基础上加上 border，不算内容溢出。 2.offsetTop:获取当前盒子元素外边框距离其父级参照参照物内边框的上偏移(不包含定位的情况是 body) 3.offsetLeft:获取当前盒子元素外边框距离其父级参照参照物内边框的左偏移(不包含定位的情况是 body) 4.offsetParent:同一个平面默认都是 body 同一个平面默认参照物是 body,body 的父级参照物是 Null,构建不同的平面用 z-index，但是这个属性只对定位有作用，所以改变元素的定位可以改变父级参照物 scroll(top/left/width/height) 1.scrollWidth/Height:真实内容的宽高(可能溢出的值+padding) 2.scrollTop:静止状态或者没有滚动条值是 0，垂直滚动条滚动的高度 3.scrollLeft:静止状态或者没有滚动条值是 0，横向滚动条滚动的高度 4.document.documentElement.scrollHeight/document.documentElement.scrollWidth:获取当前页面真实的宽高 5.document.documentElement.scrollHeight/document.documentElement.scrollWidth:获取当前 body 真实的宽高 JS 盒子模型属性 通过 js 盒模型属性获取值的特点 1.都是数字，不带单位 2.获取的都是整数，不会出现小数 3.获取的结果都是符合样式值，如果想获取单一样式(例如:只想获取 padding 样式)，我们的盒子模型属性就操作不了了 获取元素的单一样式值 1.dom.style.xxx 只能获取元素的行内样式 var dom = document.getElementById('outer'); dom.style.color //red 2.getComputedStyle(dom).height 只能获取元素的非行内样式 var dom = document.getElementById('outer'); getComputedStyle(dom).width //300px 获取元素的样式值 let getClass = function(curEl,attr){ if(window.getComputedStyle == undefined){ return } let val = window.getComputedStyle(curEl)[attr]; // 去除单位 reg = /^-?\\d+(\\.\\d+)?(px|rem|em|pt)?$/i reg.test(val) ? val = parseFloat(val) : null return val } 设置元素的样式值 //单独设置元素样式 let setClass = function(curEl,attr,val){ if(attr == 'opacity'){ curEl.style.opacity = val return } let reg = /^(width|height|fontSize|((margin|left)(top|left|right|bottom)?))$/i; reg.test(val) ? val +'px' :null curEl['style'][attr] = val } // 批量设置元素样式 let setGroupCss = function(curEl,options = {}){ // for in 循环只遍历当前对象可枚举的属性 for(let attr in options){ // 不获取在原型链上拓展的属性 if(options.hasOwnProperty(attr)){ setClass(curEl,attr,options[attr]) } } } setClass(dom,{ width:'200', height:'200', }) 面向对象的事件委托 优点:减少 dom 循环遍历，优化性能，采用绑定在父元素的方法，子元素点击冒泡 1 2 3 var ul = document.getElementsByClassName('ul')[0] ul.addEventListener('click', function(e) { console.log(e.target) }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-30 15:24:55 "},"web/flex.html":{"url":"web/flex.html","title":"弹性盒子","keywords":"","body":" css 盒模型 1.谈谈你对 css 盒模型的认识 盒模型包括：margin，padding，border，contenet 基本概念：标准模型+IE 模型. 2.标准模型和 IE 盒模型的却别 标准模型的宽高指的是 content 内容的宽高 IE 盒模型的宽高包含 padding 和 border 的宽高 3.css 是如何设置这两种模型的 设置为标准盒模型：box-sizing:content-box; 设置为 IE 盒模型： box-sizing:border-box; 浏览器默认为 content-box; 4.js 如何设置获取盒模型对应的宽高 dom.style.width/height : 只能取内联样式的宽和高 dom.currentStyle.width/height ：获取的是渲染之后的结果(只能 IE 支持) window.getComputedStyle(dom).width/height ：兼容性比 dom.currentStyle 好 dom.getBoundingClientRect().width/height ：计算相对于视窗的绝对位置能拿到 left/top/width/height 5.解释盒模型的边距重叠 通常情况下，如果给嵌套的子元素设置 margin，就会产生对父元素也产生同样的效果，然后这并不是我们想要的效果，我们只想对子元素设置 margin，那么我们应该怎么做呢 1.给父元素设置边框 2.给父元素添加 padding 3.父元素设置 overflow:hidden，相当于给父级创建了 bfc，块级格式化上下文 4.给子元素设置 inline-block(如果子元素是行内或者行内块级元素则不会产生边距的问题) 5.子元素脱离文本流(浮动，绝对定位,fixed) 6.BFC 的概念： BFC 决定了元素对其内容如何进行定位，以及与其他元素的关系和相互作用，具有 BFC 特性的元素可以看做是隔离了的容器，容器内的元素不会在布局上影响到外面的元素，可以理解为 BFC 为一个密闭的大箱子，箱子内的元素无论如何布局，都不会影响到外部 7.形成 BFC 的条件： body 根元素 浮动元素：float 除 none 的值 绝对定位元素：position:absolute/fixed display：inline-block,table-cells,flex overflow 除了 visible 的值(hidden,auto,scroll) 8.BFC 的作用 阻止外边距重叠，也就是块级标签竖直方向 margin 会以大的为准，也就是 margin 重叠，可以用 overflow:hidden 产生 bfc 解决 包含浮动元素 阻止元素被浮动元素遮盖 9.解决浮动子元素脱离父级文本流 overflow:hidden 弹性盒子 flex-direction:设置排列方式 justify-content:设置主轴方向的排列方式 align-items:设置纵轴方向的排列方式 flex-wrap:设置超出是否换行 align-content:设置行对齐 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:27:14 "},"web/arr.html":{"url":"web/arr.html","title":"数组方法","keywords":"","body":"常用数组方法 Array.of() Array.prototype.concat() Array.prototype.copyWithin() Array.prototype.entries() Array.prototype.every() Array.prototype.fill() Array.prototype.filter() Array.prototype.find() Array.prototype.findIndex() Array.prototype.flat() Array.prototype.flatMap() Array.prototype.forEach() Array.prototype.includes() Array.prototype.indexOf() Array.prototype.join() Array.prototype.keys() Array.prototype.lastIndexOf() Array.prototype.map() Array.prototype.pop() Array.prototype.push() Array.prototype.reduce() Array.prototype.reduceRight():区别于reduce是从右往左进行操作 Array.prototype.reverse() Array.prototype.shift() Array.prototype.slice() Array.prototype.some() Array.prototype.sort() Array.prototype.splice() Array.prototype.toLocaleString() Array.prototype.toString() Array.prototype.unshift() Array.prototype.values() Array.from() Array.isArray():结果返回true/false Array.reduce((prev,next,currentIndex,arr)={},initalValue) prev:初始值(必须) next:当前元素(必须) currentIndex:当前元素的索引(可选) arr:当前元素对象(可选) initalValue:当前元素对象(可选) // 数组求和 const arr = [1,2,3,4,5] const total = arr.reduce((prev,next)=>{ console.log(prev,next) return prev + next // return之后会改变下次的total },0) // 0 1 // 1 2 // 3 3 // 6 4 // 10 5 // 数组合并 const arr = [[1,2],[3,4],[5,6]]; const total = arr.reduce(function(newArr,itemArr){ return newArr.concat(itemArr) }, []); console.log('======total',total); //[1, 2, 3, 4, 5, 6] const arr = [\"aaa\", \"bbb\", \"ccc\"]; arr.reduce(function(prev,next){ console.log(\"prev:\",prev); console.log(\"next:\",next); return prev; // prev: 111 },'111'); // next: aaa // prev: 111 // next: bbb // prev: 111 // next: ccc Array.join() 将数组转化为字符串 var arr = [1,2,3,4] arr.join() // 1,2,3,4 arr.join('') // 1234 Array.slice(start,end) start:开始下标 end:结束下标 截取数组，不会改变改变原数组 var arr = [1,2,3,4] arr.slice(0,1) // 返回:[0,1] var arr1 = [1,2,3,4] arr1.slice() // 返回：[1,2,3,4] var arr2 = [1,2,3,4,5,6] arr2.slice(2,4) // 返回 [3,4] Array.splice(index,deleteMany,item1,...itemX) 截取数组，向数组添加元素，该方法会改变原数组 index:开始位置 deleteMany:删除的数量 item1,...itemX: 添加的项 var arr = [1,2,3,4] arr.splice(0,1,9) // 原数组：[9,2,3,4] 返回[1] var arr1 = [1,2,3,4] arr1.splice(0,1) // 原数组：[2,3,4] 返回:[1] var arr2 = [1,2,3,4,5,6] arr2.splice(2,4) // 返回：[3,4,5,6] Array.from() 该方法用于将两类对象转换成真正的数组：类数组的对象和可遍历对象 可以接受一个参数来对数组当中的每个元素进行单独处理 var obj = { 0:123, length:1 // length为必选项 } Array.from(obj) // 返回 [123] // 如果是ES5的实现 Array.prototype.slice.call(obj) //[123] // 传入函数针对每个参数进行单独处理 var arr = [1,false,false,4] Array.from(arr,(x)=>{ return x ? x : true // 返回[1,true,true,4] }) Array.of() 该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型 Array.of(1,2) // 返回[1,2] Array.of(undefined) // 返回[undefined] // ES5实现 function ArrayOf(){ return [].slice.call(arguments); } Array.copyWithin(target,start,end) target:从该位置替换数据，负值就是倒数 start:从该位置开始读取数据，默认为0，负值，从末尾开始计算 end:到该位置停止读取数据 // 将3号位复制到0号位 [1,2,3,4,5].copyWithin(0,1,2) // [2,2,3,4,5] [1,2,3,4,5].copyWithin(0,-2,-1) // [4,2,3,4,5] [1,2,3,4,5].copyWithin(1,3,4) // [1,4,3,4,5] Array.find()和Array.findIndex() 区别：Array.find()是返回符合条件的第一个成员 Array.findIndex()是返回符合条件成员的位置 // Array.find() [1,2,3,4,5].find((val)=>{ val>3 // 4 }) // Array.findIndex() [1,2,3,4,5].findIndex((val)=>{ val>3 // 3 }) // 这两个方法都可以接口第二个参数，用来绑定回调函数的this对象 function f(v){ return v > this.age } var obj = { age:20 } [19,23,21].findIndex(f,obj) // 返回：1 Arryay.fill(elem,start,end) elem:填充的数值(必填) start:开始填充的位置 end:结束的位置 [1,2,3].fill(4) // [4,4,4] [1,2,3].fill(9,2,3) // [1,2,9] entries(),keys(),values() // entreis() for(let [index,elem] of ['a','b'].entries()){ console.log(index,elem) // 0 'a' } // 1 'b' // keys() for(let elem of ['a','b'].keys()){ console.log(elem) // 0 1 } // values() for(let elem of ['a','b'].values()){ console.log(elem) // 'a' 'b' } Array.includes(elem,start) 判断数组里是否包含某项 返回true/false elem：查找的元素 start:起始位置 [1,2,3,4].includes(3) // true [1,2,3,4].includes(3,3) //false flat(),flatMap() flat():用来展开嵌套数组，会忽略空格会修改原数组 flatMap():flatMap 方法与 map 方法和深度depth为1的 flat 几乎相同. // flat():平铺数组 [1,[2,3,[4,5,[6]]]].flat(Infinity) // [1,2,3,4,5,6] // flatMap():可以忽略空格，map不忽略空格 let arr = [\"今天天气不错\", \"\", \"早上好\"] arr.map(s => s.split(\"\")) // [[\"今\", \"天\", \"天\", \"气\", \"不\", \"错\"],[],[\"早\", \"上\", \"好\"]] arr.flatMap(s => s.split('')); // [\"今\", \"天\", \"天\", \"气\", \"不\", \"错\", \"早\", \"上\", \"好\"] Array.map() 该方法创建一个新数组，结果是该数组中的每个元素调用一个函数返回的结果 var arr = [1,2,3,4] var newArr = arr.map(x=>{ return x * 2 }) console.log(newArr) //2,4,6,8 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:24:23 "},"web/string.html":{"url":"web/string.html","title":"字符串方法","keywords":"","body":"常用字符串方法 String.concat():字符串拼接 String.substr() String.substr(indexStart,indexEnd)不建议使用 indexStart:开始位置 indexEnd:截取的数量 var str = '123456' console.log(str.substr(2,3)) // 345 String.substring(indexStart,number) indexStart:开始下标 number:截取数量 var str = '123456789' console.log(str.substring(3,4)) // 4567 String.slice() var str = 'ThisisString' console.log(str.slice(3,5)) // si String.includes() String.startsWith() String.endsWith() includes():返回布尔值,是否找到了参数字符串 startsWith():返回布尔值,是否在头部找到了参数字符串 endsWith():返回布尔值,是否在尾部找到了参数字符串 var str ='Hello world!' // includes() console.log(str.includes(' wor')) //true // startsWith() console.log(str.startsWith('Hello')) //true // endsWith() console.log(str.endsWith('!')) //true String.repeat() 该方法返回一个新的字符串,表示将字符串重复N次 如果repeat的参数是负数或者Infinity，会报错 var str = '123' console.log(str.repeat(3)) // '123123123' trim String.trimStart() String.trimEnd() trim():从两端消除空格 trimStart():消除头部空格 trimEnd():消除尾部空格 都不会修改原字符串 const str = ' abc '; // trim() console.log(str.trim()) // 'abc' // trimStart() console.log(str.trimStart()) // 'abc ' // trimEnd console.log(str.trimEnd()) // ' abc' String.charAt() 从一个字符串中返回指定的字符 var anyString = \"Brave new world\"; console.log(\"The character at index 0 is '\" + anyString.charAt(0) + \"'\"); // The character at index 0 is 'B' console.log(\"The character at index 1 is '\" + anyString.charAt(1) + \"'\"); // The character at index 0 is 'r' console.log(\"The character at index 2 is '\" + anyString.charAt(2) + \"'\"); // The character at index 0 is 'a' console.log(\"The character at index 3 is '\" + anyString.charAt(3) + \"'\"); // The character at index 0 is 'v' console.log(\"The character at index 4 is '\" + anyString.charAt(4) + \"'\"); // The character at index 0 is 'e' console.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\"); // The character at index 0 is '' Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:23:58 "},"web/typeOf.html":{"url":"web/typeOf.html","title":"隐式类型转换","keywords":"","body":" 常见的数据类型 基本数据类型 number string boolean undefined null symbol bigInt 引用数据类型 object function Number()：直接调用浏览器底层的数据类型检测机制来完成 true->1 false->0 null->0 undefined->NaN \"\"->0 字符串中必须保证都是有效数字才会转换为数字，否则都是 NaN console.log('------------------') console.log(parseInt(\"\")) //NaN console.log(Number(\"\")) //0 console.log(isNaN(\"\")) // false console.log(parseInt(null)) // NaN console.log(Number(null)) // 0 console.log(isNaN(null)) // false console.log(parseInt('12px')) // 12 console.log(Number('12px')) //NaN console.log(isNaN('12px')) //true console.log(parseFloat('1.6px') + parseInt(\"1.2px\") + typeof parseInt(null)) //'2.6number' console.log(isNaN(Number(!!Number(parseInt(\"0.8\"))))) //false console.log(typeof !parseInt(null) + !isNaN(null)) // 'booleantrue' let result = 10 + false + undefined + [] + 'Tencent' + null + true + {}; // 'NaNTencentnulltrue[object Object]' parseInt():处理的值是字符串，从字符串的左侧开始查找有效数字字符(遇到有效数字则停止查找)->如果处理的值不是字符串，需要先转换为字符串然后在开始查找接口 数据类型检测 typeof:检测数据类型的逻辑运算符，Array 和 Object 都返回'object' console.log(typeof([1,2,3])) //'object' console.log(typeof(333)) //'number' console.log(typeof({a:123})) //'object' constructor:检测构造函数 console.log([1, 2, 3].constructor == Array) // true console.log({a:1}.constructor == Object) // true instanceof:判断是否是某个类的实例 console.log([1,2,3] instanceof Array) //true console.log({a:123} instanceof Object) // true Object.prototype.toString.call():不仅可以检测引用类型，还能检测普通的数据类型 console.log(Object.prototype.toString.call([1, 2, 3]) == '[object Array]') //true console.log(Object.prototype.toString.call(333) == '[object Number]') //true console.log(Object.prototype.toString.call({ a: 123}) == '[object Object]') //true 隐式类型转换 1.隐式类型转换规则 转换成 string 类型 + ,转换成 number 类型：++/--(自增自减运算符) + - * / %(算术运算符) > = 转换成 boolean 类型 !(逻辑非运算符) 字符串与算术运算符隐式转换规则混淆 字符串连接符:会把其他的数据类型调用 String()转成字符串然后进行拼接 算数运算符:会把其他的数据类型调用 Number()方法转换成数字然后做加法计算 // + 是字符串连接:String(1)+'true' console.log(1+\"true\") // 1true // + 是算数运算符:1+Number(true) = 2 console.log(1+true) // 2 // + 是算数运算符:1+Number(undefined) = NaN console.log(1+undefined) //NaN // + 是算术运算符:1+Number(null) = 1 console.log(1+null) // 1 // + 是算数运算符:1+Number([]) = 1 console.log(1+[]) // 1 // + 是算数运算符:1+Number({}) = NaN console.log(1+{}) // NaN 3.关系运算符：会把其他数据类型转换成 number 再进行比较 对象和字符串，对象转换为字符串 null == undefined 但是和其他值都不相等 剩下两边不同的转换为数字 // 当关系运算符两边一边是字符串，会将其他数据类型用Number转换，然后再进行比较 console.log(\"2\" > 10) // false // 两边都是数字都是字符串的时候使用unicode编码来转换成数字 console.log(\"2\" > \"10\") // true // 多个字符从左到右依次比较 console.log(\"abc\" > \"b\") //false // 比较aa然后b>a console.log(\"abd\" > \"aad\") // true // 特殊情况无视规则 console.log(undefined == undefined) //true console.log(undefined == null) //true console.log(null == false) // false console.log(null == null) //true console.log(NaN == NaN) // false 4.复杂数据类型 复杂数据先使用 valueOf 方法获取其原始值，如果原始值不是 number 类型，则使用 toString()类型转成 string,再将 string 转成 number // 先将左边数据转成string，然后右边也是string则转成unicode编码运算 console.log([1,2] == '1,2') //true var a = {} console.log(a == '[object Object]') //true console.log(a.valueOf().toString()) //[object Object] 5.逻辑非隐式转换与关系运算符隐式转换搞混淆 关系运算符:将其他数据类型转换成数字类型 逻辑非：将其他数据类型转换成 Boolean 类型 八种数据类型转换为 Boolean 类型会得到 false [0,-0,NaN,undefined,null,\"\",false] //原理：[].valueOf().toString() 得到空字符串 Number(\"\") == 0 console.log([] == 0) // true //原理：！运算符优先级高于关系运算符，![] == false (空数组布尔值得到true，然后取反得到false), false == 0 console.log(![] == 0) //true //原理：本质上是空对象{} 与 !{}这个逻辑非表达式结果做比较 {}.valeOf().toString()得到字符串\"[object Object]\" !{} = false Number(\"[object Object]\") == Number(false) console.log({} == !{}) //false // 引用类型数据存在堆中，栈中存储的是地址，所以结果是false console.log({}=={}) // false console.log([]==[]) //false console.log([] == {}) // false console.log({} == []) // false 值类型的工作原理 1.创建一个值 2.创建一个变量 3.让变量和值关联到一起 引用类型 1.创建一个堆内存 2.把键值对存储到堆内存当中 3.堆内存放到栈当中，供变量调用 JS 底层运行机制 ECStack(栈内存，计算机分配一块内存，全局执行的环境栈) 和 EC(代码自己执行的上下文环境) GO(Global Object):全局对象，存放在堆内存当中的 isNaN,alert 等方法 Vo(Varibale Object):当前上下文当中，用来存放创建变量和值的地方 Ao(Activation Object):私有变量对象 常见面试题 typeof 返回的值是带''号的 let a = typeof typeof typeof [12,23] console.log(a) // 'string' typeof(NaN) == 'number' let res = parseFloat('left:200px') //NaN if(res == 200){ console.log(200) }else if(typeof res === 'number'){ console.log('number') }else{ console.log('Invalid Number') } 引用类型底层原理 // 1.创建值 // + 开辟一个堆 // + 存储键值对 // name:'cc' // fn:自执行函数执行，需要把obj.name传进来 -> undefined.name var obj = { name:'cc', fn:(function(x){ console.log(x+10) })(obj.name) } obj.fn(3) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:27:41 "},"web/prototype.html":{"url":"web/prototype.html","title":"原型链","keywords":"","body":" 原型链 每个函数都拥有一个 prototype 属性，每个函数的实例对象都拥有一个proto属性，而这个属性指向了函数的 prototype，当我们访问实例对象的属性和方法的时候，会先从自身构造函数当中查找，没有就通过proto去原型中查找，这个查找的过程我们称之为原型链 // Es5 中没有类 用构造函数模拟类 // 类中有两种属性 1）实例上的属性 2）公共属性 function Animal(){ if(! (this instanceof Animal)){ throw new Error('不是继承与该构造函数') } this.name = {name:'zf'} this.ages = 10 } Animal.prototype.say = function(){ console.log('sy') } let a1 = new Animal() let a2 = new Animal() 1.创造对象的几种方法 var a = {obj:3} function Demo(){ this.name = '3' } var demo = new Demo() var c = {c:3} var newObj = Object.create(c) 原型链的 instanceof 一个构造函数的 prototype 属性所指向的对象是否存在另外一个要检测对象的原型链上 function A(){ this.name = 'this is a' } var m = new A() console.log(m instanceof A) // 手动实现instanceOf function _instanceOf(protoObj,newFun){ var funPrototype = newFun.prototype; var __proto__ = protoObj.__proto__ if(__proto__ === null){ return false } if(__proto__ === funPrototype){ return true } return false } var Object = {} var result = _instanceOf(Object,A) console.log('result',result) new 运算符实现原理 // 第一步实现原型链的关联，可以通过原型链进行查找 // 第二部就是改变this指向拿到内部的属性 function fn(name){ this.name = '123' } function newFun(fn){ // es6方法，关联原型链 var o = Object.create(fn.prototype); var k = fn.call(o,arguments) if(k === 'object'){ return k }else{ return o } } var res = newFun(fn) console.log(res.name) JS 类与继承 类的继承 function Animal() { this.type = '哺乳类' } Animal.prototype.say = function() { console.log('动物原型链的方法') } function Tiger() { this.name = '老虎' Animal.call(this) } // 原型链混乱也就是原型链共享不推荐 // Tiger.prototype = Animal.prototype // 自己找不到向上找 // Tiger.prototype.__proto__ = Animal.prototype // Es6指定了链的指向 // Object.setPrototypeOf(Tiger.prototype, Animal.prototype) // 唯一有些不同的是，他在中间加了一层 Tiger.prototype = Object.create(Animal.prototype, { constructor: { value: Tiger } }) let tiger = new Tiger() console.log(tiger.type) tiger.say() Object.create 的实现原理 function create(parentPrototype){ function Fn() fn.prototype = parentPrototype let fn = new Fn() fn.constructor = Tiger } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-02 14:09:48 "},"web/curring.html":{"url":"web/curring.html","title":"函数柯里化","keywords":"","body":" 函数柯里化 柯里化的常用场景 // 正常验证字符串 function check(reg,txt){ return reg.text(txt) } check(/\\d+/g,'text') check(/[a-z]+/g,'text') // 柯里化 function curringCheck(reg){ return function(txt){ return reg.test(txt) } } let hasNumber = curringCheck(/d+/g) let hasNumber = curringCheck(/[a-z]+/g) hasNumber('test1') hasLetter('test1') bind // 分析：这里的bind方法会把第一个实参绑定给f函数内的this，所以这里的this指向{x:1}对象 // 从第二个参数起，会依次传递给原始函数，这里的第二个参数2即是f函数的y参数 // 最后调用m(3)的时候，这里的3便是最后一个参数z了，所以执行1+2+3 = 6 // 分步处理参数的过程就是一个典型的函数柯里化的过程 function f(y, z) { return this.x + y + z } let result = f.bind({ x: 1 }, 2)(3) console.log(result) // 3 const curring = (fn,arr = [])=>{ let len = fn.length; return (...args)=>{ arr = arr.concat(args) if(arr.length { return Object.prototype.toString.call(content) === `[object ${isString}]` } } let arr = [\"String\",\"Number\",\"Boolean\"] let utils ={} arr.forEach((type)=>{ utils[`is${type}`] = curring(checkTpye)(type) }) console.log(utils.isString('123')) function checkTpye(isString){ return (content)=>{ return Object.prototype.toString.call(content) === `[object ${isString}]` } } let arr = [\"String\",\"Number\",\"Boolean\"] let utils ={} arr.forEach((type)=>{ utils[`is${type}`] = checkTpye(type) }) console.log(utils.isString(\"123\")) } bind 的实现原理 Function.prototype.my_bind = function() { const self = this const context = [].shift.call(arguments) const args = [].slice.call(arguments) return function() { self.apply(context, Array.prototype.concat.call(args, [...arguments])) } } function demo(y, p) { console.log(this.x, y, p) } console.log(demo.my_bind({ x: 1 }, 2)(3)) 经典 add 函数 function add() { let args = Array.prototype.slice.call(arguments) let _add = function() { args.push(...arguments) return _add } // 利用隐式类型转换，最后一次执行的时候返回值 _add.toString = function() { let result = args.reduce((prev, current) => { return prev + current }) return result } return _add } console.log(add(1)(2)(3) == 6) console.log(add(1, 2, 3) == 6) console.log(add(1, 2)(3) == 6) const add = (a,b,c,d,e)=>{ return a+b+c+d+e } // 经典的函数柯里化 const curring = (fn,arr = [])=>{ let len = fn.length; return (...args)=>{ arr = arr.concat(args) if(arr.length Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-12 19:00:07 "},"web/debounce.html":{"url":"web/debounce.html","title":"防抖和节流","keywords":"","body":" 函数的防抖 控制次数:输入框搜索 let a = 1 let time = null window.addEventListener('scroll', function() { if (time) clearTimeout(time) time = setTimeout(() => { console.log(a++) }, 2000) }) 函数的节流 控制频率：拖拽等高频操作 function debounce(fn, wait) { var timer = null; return function() { // 只有是null的时候才执行，也就是执行完setTimeout函数之后再执行 if (!timer) { timer = setTimeout(() => { fn() timer = null; }, wait) } } } // 函数的柯里化，拆分成细小的函数，方便维护 let fn = function() { console.log('触发') } window.onmouseover = debounce(fn, 2000) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-02 21:52:10 "},"web/fun.html":{"url":"web/fun.html","title":"发布订阅/高阶函数","keywords":"","body":" 高阶函数 发布订阅 let fs = require('fs') let school ={} let e = { //订阅 arr:[], on(fn){ this.arr.push(fn) }, // 发布事件 emit(){ this.arr.forEach((item)=>{ item() }) }, } // 订阅事件 e.on(()=>{ console.log(\"ok\") }) e.on(()=>{ if(Object.keys(school).length === 2){ console.log(school) } }) fs.readFile('./data/name.txt','utf8',(err,data)=>{ school[\"name\"] = data; e.emit(); }) fs.readFile('./data/age.txt','utf8',(err,data)=>{ school[\"age\"] = data; e.emit(); }) 观察者 class Subject{ constructor(){ // 存放观察者 this.arr = [] this.state = '开心' } chageState(newState){ this.state = newState this.arr.forEach(item=>{ item.update(this.state) }) } attach(o){ this.arr.push(o) } } class Parent{ constructor(name){ this.name = name } update(state){ console.log(this.name+'的小宝宝:'+state) } } let child = new Subject() let observer = new Parent(\"父亲\") let observer1 = new Parent(\"母亲\") child.attach(observer) child.attach(observer1) child.chageState('不开心了') 函数的 bfore AOP 切片 装饰，希望将核心逻辑拆分出来吗，在外面增加功能 Function.prototype.before = function(bfroreFn){ return (...arg)=>{ // 箭头函数没有this指向，所以会向上级作用域查找 bfroreFn(); this(...arg); } } function say(...arg){ console.log(\"arg:\",arg) } const newSay = say.before(()=>{ console.log(\"新增加的方法\") }) newSay(1,2,3,4) // js模拟事务 let perform = ((fn,wrappers)=>{ wrappers.forEach(element => { element.initlizae(); }); fn(); wrappers.forEach(element => { element.close(); }); }) perform(()=>{ console.log(\"say\") },[{ initlizae(){ console.log(\"hello\") }, close(){ console.log(\"bye\") } }]) compose:组合函数 function sum(a, b) { return a + b } function len(str) { return str.length } function addCurrency(val) { return `$${val}` } function compose(...fn) { return function(...nums) { let r = fn.pop() return fn.reduceRight((prev, current) => { return current(prev) // return current(prev(...nums)) }, r(...nums)) } } // reduex版本的compose function compose(...args) { return args.reduce((prev, current) => { return function(...values) { return prev(current(...values)) } }) } console.log(compose(addCurrency, len, sum)('abc', 'cbd')) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:22:26 "},"web/async&&await.html":{"url":"web/async&&await.html","title":"async 和 await","keywords":"","body":" async await 浏览器遇到 await 语句后，会先去执行外部的同步代码，之后再来处理 await 后面的函数的返回值。 注意：async 函数里面是从右往左执行的，因此会先执行右边的函数，之后再遇到 await 做处理。 async function async1() { console.log('async1 start') await async2() // 所以这里执行完async2函数之后，会再执行promise1 console.log('async1 end') } async function async2() { console.log('async2') } console.log('script start') setTimeout(function () { console.log('setTimeout') }, 0) async1() new Promise(function (resolve) { console.log('promise1') resolve() }).then(function () { console.log('promise2') }) console.log('script end') 先执行了 async2 函数，得到结果，遇到了 await,则先去执行外部的同步代码，因此 new Promise.then 先加入 micro task。之后，在处理 async2 得到的结果，await async2()，等同于 Promise.then，因此，再将 async2 加入 micro task. Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-25 16:08:35 "},"web/ReferenceError.html":{"url":"web/ReferenceError.html","title":"ReferenceError 和 TypeError 区别","keywords":"","body":" ReferenceError 和 TypeError 区别 ReferenceError 和 TypeError 区别在于，ReferenceError 是和作用域查找相关，TypeError 是查找作用域成功，但是对变量的操作非法或者错误所生成。 假如查找不到变量。LHS 在非严格模式下找不到变量会自动生成全局变量，但是在严格模式会和 RHS 一样 ReferenceError 的错误。 假如能查找到变量，对其进行非法或者不正确的操作都会报 TypeError 的错误。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-05-07 10:52:50 "},"web/eventLoop.html":{"url":"web/eventLoop.html","title":"js 线程","keywords":"","body":" EventLoop 什么是进程什么是线程 进程是系统进行资源分配和调度的一个独立单位，一个进程内包含多个线程 渲染进程 GUI 渲染线程(页面渲染) js 引擎线程(执行 js 脚本) 事件触发线程(eventLoop 轮询线程) 事件(onClick)，定时器(setTimeout),ajax(xhr)(独立线程) 我们所谓的 js 为什么是单线程 一个线程在某个 dom 节点上添加内容，另一个线程删除了这个节点，那以哪个为准？ eventLoop 在一个时间循环当中，异步事件返回的结果会放到一个任务队列当中，然后宏任务放宏任务队列，微任务放微任务队列 我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。在当前的微任务没有执行完成时，是不会执行下一个宏任务的。 console.log(1); // 输出1 setTimeout(function() { // 添加到宏任务 macrotask:[console.log(2)] console.log(2); }, 0); new Promise(function(resolve) { // 输出3 console.log(3); resolve(Date.now()); }).then(function() { console.log(4); // 添加到微任务 microtask:[console.log(4)] }); console.log(5); // 输出 5 setTimeout(function() { new Promise(function(resolve) { // 添加到宏任务 macrotask:[console.log(2),newPromise...] console.log(6); }).then(function() { console.log(7); }); }, 0); // 输出 1 3 5 4 2 6 setTimeout(()=>{ console.log(1) },0) new Promise((resolve)=>{ resolve() }).then(()=>{ console.log(2) }) // 输出 2 1 setTimeout(_ => console.log(4)) new Promise(resolve => { resolve() console.log(1) }).then(_ => { console.log(3) Promise.resolve().then(_ => { console.log('before timeout') }).then(_ => { Promise.resolve().then(_ => { console.log('also before timeout') }) }) }) console.log(2) // 输出 1 2 3 before timeout also before timeout 4 JS 运行机制 console.log(1) setTimeout(function(){ console.log(3) },0) console.log(2) // 输出 1,2,3 for(var i=0 ;i eventLoop 所有同步任务都在主线程上执行，形成一个执行栈， 主线程之外,还存在一个任务队列，只要异步任务有了结果,就在任务队列中放置一个事件 一旦执行栈中所有的同步任务执行完毕,系统就会读取任务队列，看看里面有哪些事件,那么对应的异步任务,于是结束等待状态,进入执行栈,开始执行 主线程不断重复上面三步 如何开启异步事件队列 setTimeout 和 setInterval DOM 事件 Promise 宏任务和微任务 微任务:promise.then MutationObserver 宏任务:script,ajax,事件,requestFrameAnimation,setTimeout,setInterval,setImmediate,MessageChannel,UI,rendering 浏览器的 eventLoop 和 node 11 版本的表现一致 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:21:56 "},"web/jsonp.html":{"url":"web/jsonp.html","title":"跨域","keywords":"","body":"多种跨域方案详解 同源策略 协议 域名 端口 一致 为什么浏览器不支持跨域 cookie LocalStorage 都具有同源限制，防止 cookie 共享带来的安全性 // 跨域强制携带cookie xhr.withCredentials = true 实现跨域的几种方式 1. jsonp 缺点：1.只能发送 get 请求 2.容易遭受 xss 攻击 JSONP 实现 // jsonp的实现 function jsonp({ url, params, cb }) { return new Promise((resolve, reject) => { let script = document.createElement('script') // 获取函数中的参数 window[cb] = function (data) { console.log('data', data) resolve(data) document.removeChild(script) } params = { ...params, cb } let arrs = [] for (let key in params) { arrs.push(`${key}=${params[key]}`) } script.src = `${url}?${arrs.join('&')}` document.body.appendChild(script) }) } jsonp({ url: 'https://www.baidu.com/sugrec', params: { wd: 'b' }, cb: 'jQuery11020574908', }).then((data) => { console.log(data) }) 2. cors 最常用的方式，后端设置 Access-Control-Allow-Origin // 伪代码 let express = require('express'); let app = express() let whitList = ['http://www.baidu.com'] app.use((req,res,next)=>{ let origin = req.headers.origin; if(whitList.includes(origin)){ res.setHeader('Access-Control-Allow-Origin',origin) // 设置允许跨域携带cookit res.setHeader('Access-Control-Allow-Credentials',true) // 设置6秒之内不会发送options请求 res.setHeader('Access-Control-Max-age',6) // 支持headers中的name属性 res.setHeader('Access-Control-Expose-Headers','name') // 三种情况会出现预请求 // 1.请求的方式不是GET/POST/HEAD // 2.POST的请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain // 3.请求设置了自定义header if(req.method == 'options'){ res.send() } } }) 3. postMessage // A页面 function load(){ let frame = document.getElementById('frame'); frame.contentWindow.postMessage('传递给B页面的内容','http://localhost:4000'); } //监听B页面传递过来的消息 window.onmessage = function(e){ console.log(e.data); e.source.postMessage('我拒收了b页面的消息'，e.origin) } // B页面 window.onmessage = function(e){ console.log(e.data); e.source.postMessage('我拒收了A页面的消息'，e.origin) } 4. document.domain document.domain：返回当前文档的服务器域名 前提条件:这两个域名必须属于同一个基础域名，而且所用协议，端口都必须一致，否则无法使用 documeng.domain 进行跨域 前提条件满足之后利用 document.domain 设置为同一个一级域名就可以实现跨域 // 一级域名 http://www.baidu.com // 二级域名 http://movie.baidu.com // A页面 document.domain = 'zf1.cn' function load(){ var iframe = document.getElementById('frame'); console.log(iframe.contentWindow.a) } // B页面 document.domain = 'zf1.cn' var a = '123' 5. window.name // A和B是同域的 // C是不同域的 // a先获取C的数据 c把值放在window上面，然后把a的引用地址改到B,这样的话name不会消失 let first = true function load(){ if(first){ let iframe = document.getElementById('frame'); iframe.src = 'http://localhost:3000/b.html' first = false }else{ console.log(iframe.contentWindow.name) } } 6. locaiton.hash // 路径后面的hash值可以用来通信 // 目的是a想访问C,a和b页面是同源的 // a给c传一个hash值，c收到hash值后，C把Hash值传递给B，b将结果放到a到hash值中 // A页面 window.onhashchange = function(){ console.log(locaiton.hash) } // B页面 // 设置a页面的hash值，触发a页面的onhashchange方法拿到hash值 window.parent.parent.location.hash = location.hash // C页面 console.log(location.hash) // 这里可以获取A页面传递过来的hash值 let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe) 7. http-proxy 常见项目当中的解决跨域问题就是配置 proxy 使用的就是 http-proxy-middleware 插件 8. nginx 高性能的 HTTP 和反向代理的服务器 9. websocket websocket 和 Http 协议的区别 websocket 是双向连接，Http 是单向连接 // web var ws = new WebSocket(\"wss://echo.websocket.org\"); // 建立连接，发送消息 ws.open = function(evt){ console.log(\"Connection open ...\"); ws.sned(\"This is message\"); } // 监听收到的消息 ws.onmessage = function(evt){ console.log(\"Recived Message:\"+evt.data) ws.close() } // 监听关闭 ws.onclose = function(evt){ console.log(\"connection closed\") } // node let express = require('express'); let app = express(); let webSocket = require('ws'); let wss = new webSocket.Server({prt:3000}); wss.on('connection',function(ws){ wss.on('message',function(data){ console.log(\"data\",data) ws.end('发送给客户端的消息') }) }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:27:17 "},"web/nginx.html":{"url":"web/nginx.html","title":"nginx","keywords":"","body":"nginx详解 nginx是一个开源而且高性能的、可靠的HTTP中间件和代理服务器 关闭iptables iptables命令是Linux上最常用的防火墙软件 停止防火墙: systemctl stop firewalled.service 永久关闭防火墙: systemctl disable firewalled.service 确认停用selinux 安全增强型的linux，是一个linux的内核模块，也是linux的一个安全子系统 停止:setenforce 0 安装linux所需模块 yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake yum -y install wget httpd-tools vim nginx的优势 IO多路复用 多个描述符的IO操作都能在一个线程里并发交替顺序完成，复用多线程 select线程(类似于轮询是否完成):线性遍历文件描述符列表1.效率低下2.最多只有1024 epoll(nginx模型):每当fd就绪，采用系统回调函数将fd放下1.效率高2.没有1024限制 编写linux配置 vi /etc/yum.repos.d/nginx.repo [nginx] name=nginx repo baseurl = http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0 enabled=1 安装nginx yum install nginx Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:23:19 "},"web/regExp.html":{"url":"web/regExp.html","title":"正则","keywords":"","body":"正则详解 每一个正则都是由\"元字符\",\"修饰符\",两部分组成 正则两个斜杠之间包起来的都是\"元字符\" 斜杠后面出现的都是\"修饰符\" 创建正则的两种方式 let reg1 = /^\\d+$/g; //字面量 let reg2 = new RegExp(\"^\\\\d+$\",\"g\") //构造函数方式 常用的修饰符 i:ignoreCase 忽略大小写匹配 m:multiline 多行匹配 g:global 全局匹配 常用的元字符 // [特殊元字符] \\D 非0-9之间的任意字符 \\d 0-9之间的一个数字 \\n 匹配一个换行符 \\b 匹配边界符 'zhu' (z左边u右边就是边界) \\s 匹配任意一个空白字符(包括制表符table键四个空格) \\w \"数字、字母、下划线\"中的任意一个 == ([0-9a-zA-Z]) \\ 转义字符(例如:\\d，把有特殊含义的字符转换为普通意思) . 代表是除了\\n以外任意字符 ^ 以某个元字符开头 $ 以某个元字符结尾 x|y x或者y中的任意一个 [xyz] x或者y或者z中的任意一个 [^xyz] 除了x/y/z以外任何一个字符 [a-z] 获取a-z中的任意字符 ([0-9] 等价于 \\d) [^a-z] 除了a-z之外的任意字符 () 正则分组 (?:) 当前分组只匹配不捕获 (?=) 正向预查 (?!) 反向预查 ...... // [量词元字符:让其左边的元字符出现多少次] * 出现零到多次 ？ 出现零到一次 + 出现一到多次 {n} 出现n次 {n,} 出现n到多次 {n,m} 出现n到m次 // [普通元字符] 只要在正则中出现的元字符，(在基于字面方式创建)，除了特殊和有量词意义的以外，其余的都是普通元字符 元字符 [ ] 详解 在[ ]中出现的元字符一般都是代表本身含义 [ ] 中出现的两位数，不是两位数，而是两个数字中的任意一个 // \\n 匹配换行符 let reg = /^\\n$/ console.log(reg.test('\\n')) //=>true console.log(reg.test('3')) //=>false console.log(reg.test('n')) //=>false //^开头 $结尾，那么代表的含义是只能是xx let reg = /^.$/ console.log(reg.test('n')) //=>true console.log(reg.test('1')) //=>true console.log(reg.test('\\n')) //=>false console.log(reg.test('nn')) //=>false // []中的字符有消除特殊含义的功能 let reg = /^[.]+$/ console.log(reg.test('..')) //=>true console.log(reg.test('n')) //=>false console.log(reg.test('1')) //=>false console.log(reg.test('\\n')) //=>false console.log(reg.test('nn')) //=>false // [\\d]依然是0-9中的一个数字 let reg = /^[\\d]$/ console.log(reg.test(0)) //=>true // [17] 匹配 1或者 7 let reg = /^[17]$/ console.log(reg.test('8')) //=>false console.log(reg.test('1')) //=>true console.log(reg.test('7')) //=>true // [12-93] 其实匹配的是 1或者3 2-9 let reg = /^[12-93]$/ console.log(reg.test('7')) //=>true // 匹配18-65岁之间 // 18~19 // 20~59 // 60~65 let reg = /^(1[89])|([2-5][0-9])|(6[0-5])$/ console.log(reg.test(\"55\")) // 匹配[Object AAAA] 必须使用\\转义 let reg = /^\\[object [A]{4}\\]$/ console.log(reg.test('[object AAAA]')) 常用正则 // 有效数字的正则 // 1.正数 负数 零 // 2.小数 整数 // 规则:1.可以出现+/-号，可以没有，也可以有一个 // 2.整数0 12 9：一位或者多位数字，一位0-9，多位数字不能以0开头 // 3.小数部分：可能有可能没有，有小数点后面至少要跟一位数字 let reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ console.log(reg.test('0.3')) // 手机号码的正则 // 1.11位数字 // 2.必须以1开头 let reg = /^1\\d{10}$/; console.log(reg.test(18554209912)) // 中文姓名的正则 // 1. [\\u4E00-\\U9FA5] 代表的是涵盖所有的中文 // 2.尼古拉斯·赵四 中间可能会有· let reg = /^[\\u4E00-\\u9FA5]{2,5}(·)?[\\u4E00-\\u9FA5]{2,}$/; console.log(reg.test('尼古拉斯·赵四')) console.log(reg.test('尼古拉斯')) exec() RegExp类的方法,传入要匹配的字符串 正则的捕获有懒惰性:执行一次exec()只能捕获第一个和正则匹配的内容，多次执行还是捕获第一个 不加g多次调用exec()方法也无法匹配到全部符合的字符串，加g可以多次执行exec()方法进行匹配符合的全部字符串，需要手动多次调用， // [ // '20190818', // index: 0, // input: '20190818changcheng2017', // groups: undefined // ] let reg = /\\d+/ let str = '20190818changcheng2017' // lastIndex导致了懒惰性只能捕获匹配的第一个 console.log(reg.exec(str)) 正则捕获的懒惰性 // exec():字符串捕获 let reg = /\\d+/ let str = '20190818changcheng2017' // lastIndex导致了懒惰性只能捕获匹配的第一个 console.log(reg.exec(str)[0]) //20190818 // 无法手动更改lastIndex实现全部捕获 reg.lastIndex = 17 console.log(reg.exec(str)[0]) // 20190818 // 解决惰性捕获添加g修饰符(唯一的方案，不加g不管用什么方法都没有办法全部匹配到) let reg = /\\d+/g; let str = '20190918chang20190817' console.log(reg.exec(str)) console.log(reg.exec(str)) let reg = /\\d+/g; let str = '20190918chang20190817cheng1807' // 完整的捕获方法实现 RegExp.prototype.myExecAll = function(str){ let result = [] valArray = this.exec(str) while(valArray){ result.push(valArray[0]) valArray = this.exec(str) } return result } console.log(reg.myExecAll(str)) 正则捕获的贪婪性 正则捕获还具有贪婪性，每一次匹配的时候，总是捕获到和正则匹配中最长的内容，例如:'2'符合/d+，'2019'也符合/d+，但是捕获的是最长的内容'2019' 把问号放到量词元字符后面，代表的不是出现0次或者1次了，而是取消捕获的贪婪性 // 可以匹配出全部的项 //[ '2019', index: 5, input: 'chang2019cheng', groups: undefined ] let str = 'chang2019cheng' let reg = /\\d+/g console.log(reg.exec(str)) // 加?可以取消正则匹配的贪婪性 //[ '2', index: 5, input: 'chang2019cheng', groups: undefined ] let str = 'chang2019cheng' let reg = /\\d+?/g console.log(reg.exec(str)) 分组捕获 //在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到(数组的第一项)， // 而且把小分组匹配到的内容也单独抽出来(数组中的第二项开始就是小分组) let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/g console.log(reg.exec(str)) // [ // '{123}', // '123', // index: 4, // input: '2018{123}{456}', // groups: undefined // ] match() String类的方法,参数是正则 不加g只能匹配到第一个符合的项，加g可以匹配出所有符合的项 match方法也有自己的局限性，在正则设置了g的情况下，基于match捕获的内容只有大正则匹配的的，小分组的没有单独抽离出来， （不设置g的情况下和执行exec()是一样的） // 设置g的情况下 // [ '{123}', '{456}' ] let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/g console.log(str.match(reg)) // [ // '{123}', // '123', // index: 4, // input: '2018{123}{456}', // groups: undefined // ] let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/ console.log(str.match(reg)) ？的作用 1.量词元字符:出现0次到1次 /-?/:让减号出现一次或者不出现 2.取消贪婪性 /\\d+?/:捕获的时候只捕获最短匹配的内容 3.?:只匹配不捕获 4.?=:正向预查 5.?!:负向预查 lastIndex的影响 // 调用test()方法之后，lastIndex值也会改变 let str = 'chang2019cheng2020'; let reg = /\\d+/g; console.log(reg.test(str)); // true 这里也相当于捕获修改了lastIndex的值 console.log(reg.lastIndex) // 9 console.log(reg.exec(str)); // [ '2020', index: 14, input: 'chang2019cheng2020', groups: undefined ] // 虽然捕获的不是同一个字符串，但是正则是同一个，上一次正则处理的时候修改了它的lastIndex值， // 也会对下一次匹配的字符串产生影响 let str = 'chang2019cheng2020'; let reg = /\\d+/g; console.log(reg.exec(str)); // [ '2019', index: 5, input: 'chang2019cheng2020', groups: undefined ] console.log(reg.exec('20180809cheng2020')) // [ '2020', index: 13, input: '20180809cheng2020', groups: undefined ] RegExp.$1 浏览器中RegExp.$1只有一个，其他的操作也会覆盖这个值，所以没什么用 let str = 'chang2019cheng2020' let reg = /(\\d+)/g; console.log(reg.test(str)) // true console.log(RegExp.$1) // 2019 获取的是一个小分组匹配的内容，大正则匹配的内容无法获取 console.log(reg.test(str)) // true console.log(RegExp.$1) // 2020 console.log(reg.test(str)) // false console.log(RegExp.$1) // 2020 console.log(reg.test(str)) // true console.log(RegExp.$1) // 2019 遍历到最后又会从头开始遍历 String.replace() // replace替换的第一种形式:传入字符串匹配 let str = 'chang2019chang2020' str = str.replace(/chang/g,'aaa') console.log(str) //aaa2019aaa2020 // replace替换的第二种形式:传入正则匹配 let str = 'chang{val:10}cheng{val:20}' str = str.replace(/\\{val:(\\d+)\\}/g,'aaa') console.log(str) //changaaachengaaa // replace替换的第三种形式:回调函数的替换 let str = 'chang{val:10}cheng{val:20}' str = str.replace(/\\{val:(\\d+)\\}/g,(...arg)=>{ return 'aaa' }) console.log(str) //changaaachengaaa 时间字符串格式化 // 简单版本:根据特殊符号匹配 function filterMonth(month){ if(month.length{ let [,index] = arg; console.log(arg) return arr[index] }) console.log(template) // 时间字符串格式化的终极解决方案 String.prototype.myFormateTime = function myFormateTime(template='{0}年{1}月{2}日 {3}时{4}分{5}秒'){ let ary = this.match(/\\d+/g).map(item=>(item{ return ary[index] }) } let str = '2018/4/30 12:5:30' console.log(str.myFormateTime()) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:23:42 "},"web/mvvm.html":{"url":"web/mvvm.html","title":"mvvm","keywords":"","body":" MVVM 框架类 MVC View 传送指令到 Controller Controller 完成业务逻辑之后要求 model 改变状态 model 将新的数据发送给 View,用户得到反馈 MVVM 优点：解决项目庞大之后 Controller 里的代码会越来越臃肿，于是有了 viewModel，由类似于 vue 框架来处理,进行一个数据的传递，所以开发者只用关注 model 和 view 就可以了，相对于 mvc，MVVM 是双向数据绑定 阮一峰：MVVM http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html 3.双向绑定原理 Object.defineProperty 1.Object.defineProperty 和 Reflect.defineProperty 的区别：Reflect.defineProperty 返回的是 Boolean 值,Object.defineProperty 返回的是一个新对象 MVVM 的设计模式 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 16:27:26 "},"web/netWork.html":{"url":"web/netWork.html","title":"浏览器","keywords":"","body":" 网页内容的组成 charset：设置 html 文档的字符编码 1. doctype：提供浏览器 html 版本信息 head：html 头部 viewPort:设置用户的可视区域 1. width:控制 viewPort 的大小 height:和 width 对应，指定高度 initial-scale:初始用户缩放比例，也即是当页面第一 load 的缩放比例 maximum-scale：允许用户缩放的最大比例 minimum-scale:允许用户缩放的最小比例 user-scalable:用户是否可以手动缩放 name:设置文档的名称 charset:关键词，即用于说明网页包含的关键信息等，从而提高被搜索引擎搜索到的概率，一般设置多个关键字 1. keywords:关键词，即用于说明网页包含的关键信息等，从而提高被搜索引擎搜索到的概率，一般设置多个关键字 1. description:描述，用于描述网页的内容，主题等，最多容纳 1024 个字符，但是搜索引擎只展示前 175 个字符 1. author:作者 1. robots:机器人，seo 优化 1. http-equiv:相当于 http 文件头作用，向浏览器传回一些有用信息 expires：期限,可以用于网页的到期时间，一旦网页过期，必须到服务器重新上传 ＜meta http-equiv=\"expires\" content=\"Wed, 20 Jun 2007 22:33:00 GMT\"＞ set-cookie:如果网页到期，存盘的 cookie 将删除 ＜meta http-equiv=\"Set-Cookie\" content=\"cookievalue=xxx;expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/\"＞ content-type:设置显示字符集 1. Content-Language:设置语言 1. Http 协议类 http 主要特点 简单快速 灵活 无连接 无状态 http 报文组成 请求报文 请求行：http 方法，页面地址,http 协议，版本 请求头 User-Agent：产生请求的浏览器类型 Accept：客户端可识别的内容类型列表 Host：请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机。 空行 告诉服务端下面是请求体了 请求体 请求内容 3.响应报文：状态码，响应头，空行，响应体 4.Http 方法 Get:获取资源 Post:传输资源 Put：更新资源 Delete:删除资源 Head:获取报文首部 5.GET 和 Post 的区别 GET 回退时是无害的，而 post 会再次请求 get 的 url 是可以被收藏的，但 post 不行 get 会被浏览器主动缓存，而 post 不会，除非手动设置 get 只能进行 Url 编码，而 post 支持多种编码方式 get 参数会被完整保留在浏览器的历史记录中，而 post 不会 get 参数在 url 传送的参数有长度限制，而 post 没有限制 get 参数只接受 ASCII 字符，而 post 没有限制 get 比 post 更不安全，因为参数会暴露在 url 上，所以不能用来传递敏感信息 get 参数通过 url 传递，post 放在 requsetBody 中 6.Http 状态码 1xx 指示信息:代表请求已经被接收正在处理 2xx 成功:代表请求已经被成功接收 3xx 重定向:要完成请求必须进行进一步操作 4xx 客户端错误:请求有语法错误或者请求无法实现 5xx 服务器错误:服务器未能实现合法的请求 7.Http 持久连接 keep-Alive，(1.1 版本才支持)当使用此功能时，keep-alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求的时候，keep-alive 功能避免了建立或者重新创建连接 8.http 管线化 什么是管线化 在使用持久连接的情况下，某个连接消息的传递类似于 请求 1 -> 响应 1 -> 请求 2 -> 响应 2 管线化:某个连接上的消息变成了类似这样 请求 1 -> 请求 2 -> 请求 3 -> 响应 1 -> 响应 2 -> 响应 3 【注】 那么持久连接和管线化的区别在于： 持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求 1 的响应收到之后，才会发送请求 2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。实现并行发送请求 只有 GET 和 HEAD 要求可以进行管线化，而 POST 则有所限制 初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。 4.HTTP1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器 Chrome 和 Firefox 默认并未开启管线化支持。 9.http 的多路复用 在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。 HTTP/2 的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。 通信类 服务器同源策略(协议，域名，端口) 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互， 这是一个用来隔离恶意文件关键的安全机制 cookie，LocalStorage,indexDB 无法读取 DOM 无法获得 ajax 无法发送 前后端如何通信 ajax webSocket CORS：跨域请求，后端设置请求头许可，Access-Control-Allow-Origin：* 手写原生 ajax 请求 跨域通信的几种方式 JSONP:动态加载 script 脚本，传回调名，然后获取函数里面的参数，arguments[0] Hash // 伪代码 // 利用hash，场景是当前页面A通过iframe嵌入跨域的页面B // A中的代码 var B = document.getElementsByTagName(\"iframe\"); B.src = B.src + '#' + 'data' //在B中的代码 window.onhashchange = function(){ var data = window.location.hash; } postMessage // postMessage // 窗口A(http://A.com)向跨域的窗口B(http://B.com)发送信息 Bwindow.postMessage('data','http://B.com'); //在B窗口中监听 window.addEventListener('message',function(event){ console.log(event.origin) // http://A.com console.log(event.source) // Bwindow console.log(event.data) // 'data' }) WebSocket var ws = new WebSocket(\"wss://echo.websocket.org\"); // 建立连接，发送消息 ws.open = function(evt){ console.log(\"Connection open ...\"); ws.sned(\"This is message\"); } // 监听发送消息 ws.onmessage = function(evt){ console.log(\"Recived Message:\"+evt.data) ws.close() } // 监听关闭 ws.onclose = function(evt){ console.log(\"connection closed\") } CORS // CORS // url(必须) options(可选) fetch(\"http://W.JSON\",{ }).then(function(response){ }).catch(function(err){ // 出错的，等于then的第二个参数 }) 安全类 CSRF 因为登陆了网站 A 之后，已经下发了 cookie，点击 B 网站的时候,诱导发送 get 请求,这时候的话用户发送的请求就携带 cookie 了 攻击条件: 在 A 网站已经登陆过，如果没有登录肯定拿不到 cookie，就会让他登录 接口存在未校验 refer 等情况 解决方案: 后台校验请求头的 refer token 验证 隐藏令牌:隐藏在 header 头当中，把信息校验 XSS 跨域脚本攻击 攻击方式：输入框脚本注入 浏览器渲染机制 什么是 DOCTYPE 以及作用 DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要用途是文件合法性校验，如果文件代码不合法，那么浏览器解析便会出一些差错。 HTML5 HTML 4.0 有两个模式：严格模式和宽松模式 DOM: Document Object Model，浏览器将 HTML 解析成树形的数据结构，简称 DOM CSSOM: Css Object Model,浏览器将 CSS 解析成树形的数据结构，简称 CSSOM Render Tree: DOM 和 CSSOM 合并生成 Render Tree Layout: 计算出 Render Tree 每个节点的具体位置 Painting: 通过显卡，将 Layout 后的节点内容分别呈现在屏幕上 加载顺序： 当我们获取到 HTML 文件的时候，会自上而下进行加载，并在加载过程中解析和渲染 加载说的是获取资源文件的过程，如果在加载过程当中遇到外部的 css 文件和图片，浏览器会发送请求获取 css 文件和图片，这个过程是异步的，并不会影响 HTML 文件的加载 但是如果遇到 Js 文件，HTML 文件会挂起，等待 js 文件加载完再进行渲染 为什么 HTML 文件会等待 Js 文件加载，因为 JS 可以操作 DOM，导致后续 HTML 资源白白加载，所以会等待 JS 文件加载完成之后再进行渲染，所以 JS 文件引入要在 body 底部 提升页面性能的几种方法 异步加载的方式 动态脚本加载，defer，async 异步加载的区别 defer 实在 html 加载完毕之后才会执行,如果多个，按照加载的顺序依次进行执行 async 是在加载完成之后立即执行，如果是多个,执行顺序和加载顺序无关 前端错误监控 即时运行的错误 try catch window.onerror()：错误回传服务器，但是有跨域问题，需要在 js 文件引入的时候加上 crossorigin 资源加载的错误 object.onerror(): 例如图片之类的地址加载失败，可以在标签上添加 onerror 函数，然后相对应的函数内写捕获错误的具体代码 performance.getEntries():获取加载资源的各项数据，大小，时间等等 自定义 error 事件：window.addEventListener 错误上报的原理 ajax 上传 利用 img 对象上报 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-30 10:35:21 "},"web/reflow.html":{"url":"web/reflow.html","title":"重绘和回流","keywords":"","body":" 你真的了解回流和重绘吗 回流和重绘可以说是每一个 web 开发者都经常听到的两个词语，我也不例外，可是我之前一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合一些例子，写了这篇文章，希望可以帮助到大家。 浏览器的渲染过程 本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自MDN） 从上面这个图上，我们可以看到，浏览器渲染过程如下： 解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树 将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给 GPU，展示在页面上。（这一步其实还有很多内容，比如会在 GPU 将多个合成层合并为同一个层，并展示在页面中。而 css3 硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客） 渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。 生成渲染树 为了构建渲染树，浏览器主要完成了以下工作： 从 DOM 树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到 CSSOM 树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如 script、meta、link 等。 一些通过 css 进行隐藏的节点。比如 display:none。注意，利用 visibility 和 opacity 隐藏的节点，还是会显示在渲染树上的。只有 display:none 的节点才不会显示在渲染树上。 注意：渲染树只包含可见的节点 回流 前面我们通过构造渲染树，我们将可见 DOM 节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示： Critial Path: Hello world! Hello world! 我们可以看到，第一个 div 将节点的显示尺寸设置为视口宽度的 50%，第二个 div 将其尺寸设置为父节点的 50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图） 重绘 最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。 既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。 何时发生回流重绘 我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况： 添加或删除可见的 DOM 元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 注意：回流一定会触发重绘，而重绘不一定会回流 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 浏览器的优化机制 现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 减少回流和重绘 好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。 最小化重绘和重排 由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对 DOM 和样式的修改，然后一次处理掉。考虑这个例子 const el = document.getElementById('test') el.style.padding = '5px' el.style.borderLeft = '1px' el.style.borderRight = '2px' 例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。 因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式： 使用 cssText const el = document.getElementById('test') el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;' 修改 CSS 的 class const el = document.getElementById('test') el.className += ' active' 批量修改 DOM 当我们需要对 DOM 对一系列修改的时候，可以通过以下步骤减少回流重绘次数： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对 DOM 的所有修改都不会引起回流，因为它已经不在渲染树了。 有三种方式可以让 DOM 脱离文档流： 隐藏元素，应用修改，重新显示 使用文档片段(document fragment)在当前 DOM 之外构建一个子树，再把它拷贝回文档。 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 考虑我们要执行一段批量插入节点的代码： function appendDataToElement(appendToElement, data) { let li for (let i = 0; i 如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。 我们可以使用这三种方式进行优化: 隐藏元素，应用修改，重新显示 这个会在展示和隐藏节点的时候，产生两次重绘 function appendDataToElement(appendToElement, data) { let li for (let i = 0; i 使用文档片段(document fragment)在当前 DOM 之外构建一个子树，再把它拷贝回文档 const ul = document.getElementById('list') const fragment = document.createDocumentFragment() appendDataToElement(fragment, data) ul.appendChild(fragment) 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 const ul = document.getElementById('list') const clone = ul.cloneNode(true) appendDataToElement(clone, data) ul.parentNode.replaceChild(clone, ul) 对于上述那种情况，我写了一个demo来测试修改前和修改后的性能。然而实验结果不是很理想。 原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。 避免触发同步布局事件 上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个 p 标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码： function initP() { for (let i = 0; i 这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了 box 的一个 offsetWidth 属性值，然后利用它来更新 p 标签的 width 属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为: const width = box.offsetWidth function initP() { for (let i = 0; i 同样，我也写了个demo来比较两者的性能差异。你可以自己点开这个 demo 体验下。这个对比差距就比较明显。 对于复杂动画效果,使用绝对定位让其脱离文档流 对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个例子。 打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。 从上图中，我们可以看到，帧数一直都没到 60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定 60。 css3 硬件加速（GPU 加速） 比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3 硬件加速就闪亮登场啦！！ 划重点：使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。 如何使用 常见的触发硬件加速的 css 属性： transform opacity filters Will-change 效果 在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。 重点 使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 css3 硬件加速的坑 如果你为太多元素使用 css3 硬件加速，会导致内存占用较大，会有性能问题。 在 GPU 渲染字体会导致抗锯齿无效。这是因为 GPU 和 CPU 的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 总结 本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-30 14:19:16 "},"web/data.html":{"url":"web/data.html","title":"数据类型","keywords":"","body":" 前端数据结构 队列 栈 链表 集合 hash 表 树 图 队列:先进先出 class Queue { constructor() { this.queue = [] } enqueue(element) { this.queue.push(element) } dequeue() { this.queue.shift() } } let newQueue = new Queue(); newQueue.enqueue(1) newQueue.enqueue(2) newQueue.dequeue() console.log(newQueue.queue) 栈:后进先出 // 执行上下文栈:执行a执行b执行c 然后 销毁c销毁b销毁a,是从里往外的，闭包就是执行上下文没有被销毁 function a(){ function b(){ function c(){ } c() b() } a() 栈结构模拟 class Stack { constructor() { this.stack = [] } put(element) { this.stack.push(element) } pop() { this.stack.pop() } } let newStack = new Stack(); newStack.put(1) newStack.put(2) newStack.pop() console.log(newStack.stack) 链表 单项链表 双向链表 循环链表 操作数据不需要破坏数据的原有结构 链表的性能要优于数组，因为数组是强顺序 class Node { constructor(element) { this.element = element this.next = null } } class LinkList { constructor() { this.head = null this.length = 0 } insert(position, element) { let node = new Node(element) if (!this.head) { this.head = node } else { let index = 0 let current = this.head let previous = null while (index++ 集合 set 的特点就是 key 和 value 是相同的 class Set { constructor() { this.set = {} } add(element) { if (!this.set.hasOwnProperty(element)) { this.set[element] = element } } } let a = new Set() a.add(1) a.add(2) console.log(a) 集合重点：交集差集 // 数组的交集 和 差集 has来实现 set方法只有forEach方法 let s1 = new Set([...a1]); // [1,2,3] let s2 = new Set([...a2]); // [1,2,3] let a3 = [...s2].filter((item=>{ // 返回的是一个新的数组 return !s1.has(item); // map是映射一个新的数组 但是不会比以前的项少 })); console.log(a3); map 原理 : 生成唯一的 key，存放对应的值 hashTable 取值快 而且 es6 已经提供了 class Map{ // 松散 重复的话可以在加上链表 constructor(){ this.arr = []; } calc(key){ let total = 0; for(let i = 0 ; i 二叉树 class Node { constructor(element) { this.element = element; this.left = null; this.right = null; } } class Tree { constructor() { this.root = null } insert(newNode, element) { // 如果小于 if (element 十进制转二进制 function binarySystem(shang, arr = []) { if (Math.floor(shang / 2) != 0) { arr.push(shang % 2) binarySystem(Math.floor(shang / 2), arr) } else { arr.push(shang) } return arr.join('') } console.log(binarySystem(58)) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-10 14:05:52 "},"web/ajax.html":{"url":"web/ajax.html","title":"ajax","keywords":"","body":" ajax function ajax(obj) { let promise = new Promise(function(resolve, reject) { let xhr = new XMLHttpRequest() xhr.open(obj.method, obj.url) xhr.setRequestHeader('Content-Type', obj.header || \"application/x-www-form-urlencoded\") xhr.onreadystatechange = () => { //Http完全被接收 if (xhr.readyState == 4) { // 状态码为4 if (xhr.status == 200) { resolve(xhr.response) } else { reject(new Error(xhr.statusText)) } } } xhr.send(obj.data || {}) }) return promise } ajax({ method: 'GET', url: 'data.json' }).then((data) => { console.log('data1', data) }, (err) => { console.log('errr', err) }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-30 14:01:38 "},"web/algorithm.html":{"url":"web/algorithm.html","title":"常见算法题","keywords":"","body":" 函数的柯里化 function add() { let args = Array.prototype.slice.call(arguments) let _add = function() { args.push(...arguments) return _add } // 利用隐式类型转换，最后一次执行的时候返回值 _add.toString = function() { let result = args.reduce((prev, current) => { return prev + current }) return result } return _add } console.log(add(1)(2)(3) == 6) console.log(add(1, 2, 3) == 6) console.log(add(1, 2)(3) == 6) 冒泡排序:后一个和前一个比较，后一个小于前一个，就交换位置 var arr = [5, 2, 33, 12, 9, 1] function sort(arr) { for (var i = 0; i 选择排序:默认第一个是最小的，然后每次拿当前数组剩余的最小值，和当前的最小值进行交换 var arr = [5, 2, 33, 12, 9, 1] function sort(arr) { for (let i = 0; i 快速排序:数组切割成三部分，取出中间的值，小于的值放在左边，大于的值放在右边，然后递归 function quick(arr) { if (arr.length 插入排序 function insert(arr) { // 准备一个数组，用来存储手里的牌，默认抓第一张 let currentArr = [] currentArr[0] = arr[0] for (let i = 1; i = 0; j--) { // 每次拿新抓的牌和放在数组中的牌进行比较，如果大，就放在后面 console.log(newCurrent, currentArr[j]) if (newCurrent > currentArr[j]) { currentArr.splice(j + 1, 0, newCurrent) break; } // 如果都比之前的牌小，那就放在最前面 if (j == 0) { currentArr.unshift(newCurrent) } } } } var arr = [5, 7, 33, 12, 9, 1] insert(arr) 希尔排序 Array.prototype.shell = function() { let gap = Math.floor(this.length / 2) while (gap >= 1) { for (let i = gap; i = 0 && this[i] 数组扁平化 var a = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] console.log(a.flat(Infinity)) var a = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] arr.toString().split(',') var arr = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] function demo(arr) { let result = [] let fn = (arr) => { arr.forEach((item) => { if (Object.prototype.toString.call(item) == '[object Array]') { fn(item) } else { result.push(item) } }) } fn(arr) return result } console.log(demo(arr)) 输入一个 N，输出所有和为 N 的连续正数序列 function createArr(i, j) { let arr = new Array(j) arr.fill(null) arr = arr.map((item, index) => { return i++ }) return arr } // 中间一份为二。中间的数加后面任意的数都大于目标数 function fn(count) { let result = [] let middle = Math.ceil(count / 2) // 从1开始累加 for (let i = 1; i count) { break } else if (total == count) { result.push(createArr(i, j)) break } } } return result } console.log(fn(15)) 找出数组中和为 N 的两个正数，并返回他们的数组下标 var arr = [1, 6, 4, 8, 7] function func(nums, target) { for (var i = 0; i var arr = [1, 0, 3, 8, 7] function fn(nums, target) { let obj = {} for (var i = 0; i 具有最大和的连续子数组 let arr = [-2, 2, -1, 3, -3] function maxSubArray(arr) { // 假设第一项是最大值 let ans = arr[0] let sum = 0 for (let i = 0; i 0) { sum = sum + arr[i] } else { sum = arr[i] } ans = Math.max(ans, sum) } return ans } console.log(maxSubArray(arr)) 合并两个有序数组 var a = [1, 321, 421, 5215] var c = [41, 432, 532, 5] var d = a.concat(c).sort((a, b) => a - b) console.log(d) let arr1 = [1, 5, 8, 16, 26] let arr2 = [4, 7, 9, 17] function sort(arr1, arr2) { // 总索引 let len = arr1.length + arr2.length - 1 let len1 = arr1.length - 1 let len2 = arr2.length - 1 while (len1 >= 0 && len2 >= 0) { if (arr1[len1] > arr2[len2]) { arr1[len] = arr1[len1] len1-- } else if (arr1[len1] // 斐波那契数列 [1,1,2,3,5,8,13,21...] function fibonacci(count) { if (count 0) { let current = arr[arr.length - 1] let next = arr[arr.length - 2] arr.push(current + next) n-- } return arr } console.log(fibonacci(4)) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 15:41:22 "},"web/error.html":{"url":"web/error.html","title":"前端错误监控","keywords":"","body":"前端错误监控 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-06-02 10:33:29 "},"web/monitor.html":{"url":"web/monitor.html","title":"前端错误监控","keywords":"","body":"前端错误监控 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-06-02 10:35:17 "}}