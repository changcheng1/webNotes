{"./":{"url":"./","title":"Introduction","keywords":"","body":" 学习笔记 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-17 11:23:57 "},"web/es6/解构赋值.html":{"url":"web/es6/解构赋值.html","title":"es6","keywords":"","body":" // 解构赋值 ... // 解构的方式都是根据key来实现 let [,age] = ['姓名','年龄']; console.log(age); // 用：号来重新命名 = 可以用来赋值默认值 let {name,age:age1,address=\"回龙观\"} = {name:'珠峰',age:10}; console.log(name,age1,address); // 剩余运算符 只能用在最后一项 let [,...args] = ['珠峰',10,'回龙观']; // slice console.log(args); // 对象的剩余运算符 let {name,...args} = {name:'珠峰',age:10}; console.log(args); // 展开运算符 合并数组 、 合并对象 concat let a1 = [1,2,3]; let a2 = [4,5,6,1,2,3]; console.log([...a1,...a2]); // 数组的去重 数组的交集 差集 // （set + map) set 和map 是es6中新的数据类型 不能放重复的 let set = new Set([1,2,3,3,2,1]); console.log(set); // 没有key属性 set.add(4); // set.clear()// 清除 // set.delete(); // 删除某一项 console.log(set.entries()) // Object.entries Object.keys Object.values // // Symbol.iterator set.forEach(item=>{ console.log(item); }) console.log(set.has(1)) // 数组去重 let a1 = [1,2,3]; let a2 = [4,5,6,1,2,3]; let s1 = new Set([...a1,...a2]); console.log([...s1]); // 数组的交集 和 差集 has来实现 set方法只有forEach方法 let s1 = new Set([...a1]); // [1,2,3] let s2 = new Set([...a2]); // [1,2,3] let a3 = [...s2].filter((item=>{ // 返回的是一个新的数组 return !s1.has(item); // map是映射一个新的数组 但是不会比以前的项少 })); console.log(a3); // map 和set 用法基本一致 // 展开对象 // a => 0xff => {b:2} // ... Object.assign(es6语法) // 浅拷贝 拷贝出来的结果 和以前没关系 叫深拷贝 ... 如果用的是多层对象 那就是浅拷贝 let school = { name: \"珠峰\", age: 10 ,a:{b:2},fn:()=>{},c:undefined,reg:/\\d+/}; let my = { address: \"回龙观\" }; let newObj = { ...school, ...my }; newObj = JSON.parse(JSON.stringify(newObj)); // ？ newObj.a.b = 100; console.log(newObj); // 如何实现深拷贝 // -------- // 实现一个深拷贝 递归拷贝 lodash =》cloneDeep let school = { name: \"珠峰\", age: 10, a: { b: 2 }, fn: () => {}, c: undefined, reg: /\\d+/ }; // 1) 怎么判断数据的类型 // typeof object Array // Object.prototype.toString.call() // instanceof 可以判断类型 判断是谁的实例 // constructor 构造函数 const deepClone = (value ,hash = new WeakMap) => { if(value == null) return value; // 排除掉null 和undefine 的情况 if(typeof value !== 'object') return value; // 这里包含了函数类型 if(value instanceof RegExp) return new RegExp(value); if(value instanceof Date) return new Date(value); // ..... // 拷贝的人可能是一个对象 或者是一个数组 (循环) for in let instance = new value.constructor; // 根据当前属性构造一个新的实例 if(hash.has(value)){ // 先去hash中查看一下是否存在过 ，如果存在就把以前拷贝的返回去 return hash.get(value); // 返回已经拷贝的结果 } hash.set(value,instance);// 没放过就放进去 // 用一个对象来记忆 for(let key in value){ // 一层 if(value.hasOwnProperty(key)){ // 将hash 继续向下传递 保证这次拷贝能拿到以前拷贝的结果 instance[key] = deepClone(value[key],hash); // 产生的就是一个新的拷贝后的结果 }// 过滤掉原型链上的属性 } return instance }; let obj = {a:1}; obj.b = obj; // 如果obj 已经被拷贝了一次 那下次 在用到obj的时候 直接返回就好了 不需要再次拷贝了 console.log(deepClone(obj)); let arr = [1,2,3,[4,5,6]] let newArr = deepClone(arr) newArr[3][2] = 100; console.log(arr); // set / map 也是不能放重复的项 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 11:16:48 "},"web/es6/array.html":{"url":"web/es6/array.html","title":"array","keywords":"","body":" { // 把一组数字转化为数组的方法 let arr = Array.of(3, 4, 7, 9, 11) console.log('arr=', arr) let empty = Array.of() console.log('empty', empty) } { // Array.from():可以将伪数组转化为真正的数组。 let p = document.querySelectorAll('p') let pArr = Array.from(p) pArr.forEach(function (item) { console.log(item.textContent) }) // Array.from():还有类似于map的作用 console.log(Array.from([1, 2, 3, 4, 5], (item) => { return item * 2 })) } { //Array.fill():对数组进行填充(填充内容,开始位置，结束位置-1) console.log('fill-7', [1, 'a', undefined].fill(7)) console.log('fill-7', [1, 2, 3, 4, 5, 6, 7].fill(7, 1, 3)) // [1, 7, 7, 4, 5, 6, 7] } { // Array.keys():数组进行遍历Index for (let index of [1, 2, 3, 4].keys()) { console.log('index', index) } // Array.values():数组进行遍历value for (let value of [1, 2, 3, 4].values()) { console.log('value', value) } // Array.entries():数组进行遍历value和Index for (let [index, value] of [1, 2, 3, 4, 5].entries()) { console.log('index', index, 'value', value) } } { // Array.copyWithin(替换的位置，从开始的位置读取的数) console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)) // [4,2,3,4,5] console.log([1, 2, 3, 4, 5].copyWithin(2, 1, 2)) // [1,2,3,4,5] } { //Array.find():返回符合条件的数组成员 console.log([1, 2, 3, 4, 5, 6].find((item) => { return item > 2 })) // 3 // Array.findIndex():返回符合条件的数组成员所在的key console.log([1, 2, 3, 4, 5, 6].findIndex((item) => { return item > 0 })) //3 } { //Array.includes():检测数组里面是否包含某个元素 console.log('number', [1, 2, NaN].includes(NaN)) // number true } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:41:41 "},"web/es6/class.html":{"url":"web/es6/class.html","title":"class","keywords":"","body":" // 类 // __proto__ 指向所属类的原型 // prototype 所有类都有一个prototype属性 // constructor prototype.constructor 每个类的原型上都有这个属性 // 继承公共属性prototype 继承实例上 // class Animal { // // type = '哺乳类'; // 声明到实例上的 // // constructor(){ // // this.type = '哺乳类' // // } // get a(){ // Object.defineProperty(Animal.protoype,a) // return 1; // Animal.prototype.a = 1; // } // say(){ // 放到了原型上 // Animal.prototype.say // console.log(this); // } // // 静态属性就是定义到类上的属性 es6中只有静态方法 // static get flag(){ // es6的静态属性 // return '动物' // } // } // let animal = new Animal(); // 如果将类中的方法拿出来用必须绑定this 否则默认指向undefind // console.log(Animal.flag) // let say = animal.say.bind(animal) // say(); // 静态方法在es6中也会被子类继承 class Animal{ static flag = 1; constructor(name){ this.name = name; this.type = '哺乳类' } say(){ console.log('say') } } // Tiger.__proto__ = Animal // call + Object.create() + Object.setPrototypeOf // 通过Object.defineProperty实现了 原型 + 静态方法属性的定义 class Tiger extends Animal{ constructor(name){ super(name); // 调用super Animal.call(tiger,name); // super 指代的是父类 // constructor中的super指代的问题 console.log(this) } static getAnimal(){ console.log(super.flag,'---'); // 这个super指代的是父类 } say(){ super.say(); // super 指向的是 父类的原型 } } let tiger = new Tiger('老虎'); tiger.say() // console.log(Tiger.getAnimal()); // static get / set super extends // new 的原理 function A(){ this.name = 1; this.age = 2; return {c:1} // 如果一个类返回了一个引用空间 那么实例将这个空间 } console.log(new A()) A.prototype.say = function(){ console.log('say') } function mockNew(A){ let obj = {} let returnVal = A.call(obj); if((typeof returnVal === 'object' && returnVal !== null) || typeof returnVal === 'function'){ return returnVal; } obj.__proto__ = A.prototype return obj; } let o = mockNew(A) // 1) 创建了一个一个对象,并且将对象传入到到函数中作为this // o.say(); console.log(o); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-31 10:06:53 "},"web/es6/const&let.html":{"url":"web/es6/const&let.html","title":"const & let","keywords":"","body":" // var let & const // es6 -> es5 babel // 1) 声明的变量默认声明到全局上，全局作用域 函数作用域 // {} 作用域+ let 实现一个作用域 // 2) 用var 声明的变量会导致变量提升 var function import // 用let声明的变量会绑定到当前作用域 暂存死区 // 3) var a = 1 var a = 2; 使用let 可以保证我的代码命名不重复 // 4) var 声明的变量可以更改 var a = 1 a =100 // 5) 自执行函数可以解决作用域问题 // 6) js 事件 不要用var // eslint for (let i = 0; i { console.log(i) //0,1,2,3,4,5,6,7,8,9 }); // 4ms }; // 解决 for (var i = 0; i { console.log(i) }); // 4ms })(i) //0,1,2,3,4,5,6,7,8,9 }; // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout // let & const 尽可能使用const 如果这个值需要改变 我们在更换let const obj = {}; obj.q = 1; // Assignment to constant variable. let a = 2; let a = 3; // Identifier 'a' has already been declared { console.log(a); var a = 1; } console.log(a); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-23 22:26:10 "},"web/es6/decorators.html":{"url":"web/es6/decorators.html","title":"decorators","keywords":"","body":" { // 设置类的属性不能够修改 function get(target, name, descriptor) { descriptor.writable = false; return descriptor } class test { @get time() { return '2018-07-08' } } let Test = new test() // Test.time = function () { // return '设置修改属性不能修改' // } console.log(Test.time()) } { let name = function (target) { target.myName = '常成' } @name class getName {} console.log(getName.myName) } { let log = (type) => { return function (target, name, descriptor) { let src_method = descriptor.value; console.log('target:', target) console.log('name:', name) console.log('descriptor:', descriptor) descriptor.value = (...arg) => { src_method.apply(target, arg) console.log(`log{$type}`) } } } class AD { @log('show') show() { console.log('ad is show') } @log('click') click() { console.info('ad is click') } } let ad = new AD() ad.show() ad.click() } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:50:00 "},"web/es6/function.html":{"url":"web/es6/function.html","title":"function","keywords":"","body":" 箭头函数没有 this arguments prototype { // 函数设置默认值 function test(x, y = 'hello world') { console.log('默认值', x, y) } test('hello') test('hello', 'kill') } { // 函数的作用域 let x = 'test'; function test(x, y = x) { console.log('作用域', x, y) } test('kill') } { // rest参数 function test3(...arg) { for (let v of arg) { console.log('rest', v) } } test3(1, 2, 3, 4, 'a') } { // 解构 console.log(...[1, 2, 3, 4]) console.log('a', ...[1, 2, 3, 4]) } { // 箭头函数 let arrow = v => v * 2 let arrow2 = () => 5 console.log('arrow', arrow(3)) console.log(arrow2()) } { // 函数尾调用 function tail(x) { console.log('tail', x) } function fx(x) { return tail(x) } fx(123) } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-31 11:27:26 "},"web/es6/generator.html":{"url":"web/es6/generator.html","title":"generator","keywords":"","body":" { // genertaor基本定义 let tell = function* () { yield 'a'; yield 'b'; return 'c' }; let k = tell(); console.log(k.next()); console.log(k.next()); console.log(k.next()); console.log(k.next()); } { let obj = {}; obj[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; } for (let value of obj) { console.log('value', value); } } { let state = function* () { while (1) { yield 'A'; yield 'B'; yield 'C'; } } let status = state(); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); } // { // let state=async function (){ // while(1){ // await 'A'; // await 'B'; // await 'C'; // } // } // let status=state(); // console.log(status.next()); // console.log(status.next()); // console.log(status.next()); // console.log(status.next()); // console.log(status.next()); // } // { let draw = function (count) { //具体抽奖逻辑 console.info(`剩余${count}次`) } let residue = function* (count) { while (count > 0) { count--; yield draw(count); } } let star = residue(5); let btn = document.createElement('button'); btn.id = 'start'; btn.textContent = '抽奖'; document.body.appendChild(btn); document.getElementById('start').addEventListener('click', function () { star.next(); }, false) } { // 长轮询 let ajax = function* () { yield new Promise(function (resolve, reject) { setTimeout(function () { resolve({ code: 0 }) }, 200); }) } let pull = function () { let genertaor = ajax(); let step = genertaor.next(); step.value.then(function (d) { if (d.code != 0) { setTimeout(function () { console.info('wait'); pull() }, 1000); } else { console.info(d); } }) } pull(); } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:51:50 "},"web/es6/iterator.html":{"url":"web/es6/iterator.html","title":"iterator","keywords":"","body":" { let obj = 'helloworld' let map = obj[Symbol.iterator](); console.log('array:' + map.next()) console.log('array:' + map.next()) console.log('array:' + map.next()) } { var it = Iterator(['4', '5']) console.log(it.next()) console.log(it.next()) function Iterator(array) { var nextIndex = 0 return { next: function () { console.log(array) return nextIndex Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:52:15 "},"web/es6/module.html":{"url":"web/es6/module.html","title":"module","keywords":"","body":" import 语法只能放在最外层 导入的变量不能更改赋值 // Common.js模块输入的的是只的缓存，不存在动态更新 export var foo = 'bar'; setTimeout(() => foo = 'baz', 500); // 模块重命名 将lastName改成surname import { lastName as surname } from './profile.js'; // 引入的变量只能是只读，不能进行修改，如果是对象可以改写(不建议操作) import {a} from './1.js' a = 3 // 'a' is read-only // import具有变量提升的作用 foo() import {foo} from '1.js' // 整体加载 import * as cycle from '1.js' console.log(cycle.a) // export default 本身就是输出一个叫default的变量或者方法，可以自己改名 function add(x, y) { return x * y; } export {add as default}; // 等同于 // export default add; // app.js import { default as foo } from 'modules'; // 等同于 // import foo from 'modules'; Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-26 10:55:15 "},"web/es6/Number&Math.html":{"url":"web/es6/Number&Math.html","title":"Number&Math","keywords":"","body":" { // Number.isFinite:检测一个数值是否是有限的 // Number.isNaN:检测一个数值是否是NaN console.log('15', Number.isFinite(15)) // true console.log('NaN', Number.isFinite(NaN)) // false console.log('1/0', Number.isFinite('true' / 0)) // false console.log('NaN', Number.isNaN(NaN)) // true console.log('0', Number.isNaN(0)) // false } { // Number.isInteger:判断一个数值是否为整数 console.log('25', Number.isInteger(25)) // true console.log('25.0', Number.isInteger(25.0)) // true console.log('25.1', Number.isInteger(25.1)) // false console.log('25', Number.isInteger('25')) // false } { // Math.trunc:去除一个数的小数部分，返回整数部分 console.log(4, 1, Math.trunc(4.1)) // 4 console.log(4.9, Math.trunc(4.9)) // 4 } { // Math.sign:判断一个数是正数，负数还是0，非数值会转换为数值 // 参数为正数，返回+1 // 参数为负数，返回-1 // 参数为0,返回0 // 参数为-0,返回-0 // 其他值返回NaN console.log('-5', Math.sign(-5)) // -1 console.log('0', Math.sign(0)) //0 console.log('5', Math.sign(5)) // 1 console.log('50', Math.sign('50')) // 1 console.log('foo', Math.sign('foo')) // NaN } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:53:19 "},"web/es6/object.html":{"url":"web/es6/object.html","title":"object","keywords":"","body":" { // 属性缩写 let o = 1; let k = 2; let es5 = { o: o, k: k } let es6 = { o, k } console.log(es5, es6) // 对象方法简写 let es5_method = { hello: function () { console.log('hello') } } let es6_method = { hello() { console.log('hello') } } es5_method.hello(), es6_method.hello() } { // 属性表达式 let a = 'b' let es5_obj = { a: 'c', b: 'c' } let es6_obj = { [a]: 'c' } console.log(es5_obj, es6_obj) } { // Object.is():比较两个值是否相等 console.log('字符串', Object.is('abc', 'abc'), 'abc' === 'abc') console.log('数组', Object.is([], []), [] === []) // 对象拷贝 console.log('拷贝', Object.assign({ a: 'a' }, { b: 'b' })) // 对象遍历 let test = { k: 123, 0: 456 } for (let [key, value] of Object.entries(test)) { console.log([key, value]) } } { // // 扩展运算符 // let {a,b,...c} = {a:'test',b:'kill',c:'ddd',d:'ccc'} // c={ // c:'ddd', // d:'ccc' // } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:53:52 "},"web/es6/promise.html":{"url":"web/es6/promise.html","title":"promise","keywords":"","body":" import { setTimeout } from \"timers\"; { // 定义函数 var ajax = function () { console.log('1') return new Promise(function (resolve, reject) { setTimeout(() => { resolve(\"\") }, 1000); }) } // 执行函数 ajax().then(function () { return new Promise((resolve, reject) => { console.log(\"2\") resolve(\"\") }) }).then(function () { // 返回一个promise实例 return new Promise((resolve, reject) => { console.log(\"3\") // resolve:表示允许下一步 resolve(\"\") }) }).then(function () { console.log(\"4\") }) } { let ajax = function (num) { return new Promise(function (resolve, reject) { if (num > 6) { resolve() } else { throw new Error(\"Num小于6\") } }) } ajax(7).then(function () { console.log(\"then\", \"大于6\") }).catch(function (err) { console.log(\"catch\", err) }) ajax(5).then(function () { console.log(\"then\", \"大于6\") }).catch(function (err) { // catch中err用于获取传参中的err console.log(\"catch\", err) }) } { let imgLoad = function (src) { return new Promise((resolve, reject) => { let img = new Image(); img.src = src; img.width = 300; img.height = 300; img.onload = function () { setTimeout(() => { // 传img进去 resolve(img); }, 1000) } img.onerror = function (err) { reject(err); } }) } let addImg = function (images) { images.forEach(img => { document.body.appendChild(img) }) } Promise.all([ imgLoad(\"http://img.zcool.cn/community/0142135541fe180000019ae9b8cf86.jpg@1280w_1l_2o_100sh.png\"), imgLoad(\"http://img1.imgtn.bdimg.com/it/u=3920398476,1501488149&fm=27&gp=0.jpg\"), imgLoad(\"http://img01.taopic.com/160909/240378-160ZZK14275.jpg\") ]).then(addImg) } { let imgLoad = function (src) { return new Promise((resolve, reject) => { let img = new Image(); img.src = src; img.width = 300; img.height = 300; img.onload = function () { setTimeout(() => { // 传img进去 resolve(img); }, 1000) } img.onerror = function (err) { reject(err); } }) } let addImg = function (img) { console.log(img) let p = document.createElement('p'); p.appendChild(img) document.body.appendChild(p) } // 返回promise率先完成的第一个结果 Promise.race([ imgLoad(\"http://img.zcool.cn/community/0142135541fe180000019ae9b8cf86.jpg@1280w_1l_2o_100sh.png\"), imgLoad(\"http://img1.imgtn.bdimg.com/it/u=3920398476,1501488149&fm=27&gp=0.jpg\"), imgLoad(\"http://img01.taopic.com/160909/240378-160ZZK14275.jpg\") ]).then(addImg) } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:54:13 "},"web/es6/proxy.html":{"url":"web/es6/proxy.html","title":"proxy","keywords":"","body":" // proxy 兼容性差 // 代理 我们可以创造一个代理 帮我们干某些事 let obj = { a:{a:2} } let handler = { // 只能代理当前这个对象 1层 get(target,key){ // 有13中属性 symbol 11种 // return target[key] if(typeof target[key] === 'object'){ return new Proxy(target[key],handler); // 如果是对象 就返回这个对象的代理 } return Reflect.get(target,key); }, set(target,key,value){ // 反射属性 // target[key] = value; if(key === 'length') return true; console.log('update'); return Reflect.set(target,key,value); } } let proxy = new Proxy(obj,handler) proxy.a.a = 100 console.log(obj.a.a); // 支持数组 可以直接更改数组 达到拦截的目的 // symbol 11 reflect 13种 // es6module的应用 // class // reduce // nodeh核心 } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 15:00:12 "},"web/es6/Reflect.html":{"url":"web/es6/Reflect.html","title":"Reflect","keywords":"","body":" // 未来object的方法部分会迁移到Reflect // 反射 Object.defineProperty // 里面有部分的对象的方法 放到 Reflect 功能基本一致 // Proxy 中能代理的方法 Reflect 都可以实现 // 1) get /set const obj = {}; Reflect.set(obj,'name','zf'); // obj.name = zf; console.log(Reflect.get(obj,'name')); // 2) has // 老的写法 console.log('a' in {a:1}); // 新的写法 console.log(Reflect.has({a:1},'a')); // 3)defineProperty // 把对象上的属性get set 都给重写了 const obj = {a:1} Object.freeze(obj); // 这个属性就能不能配置了 冻结freeze let flag = Reflect.defineProperty(obj,'a',{ value:100 }) console.log(flag); // 4)getOwnPropertyDescriptor const obj = {a:1}; console.log(Reflect.getOwnPropertyDescriptor(obj,'a')); // 5)ownKeys let obj = { a:1, [Symbol()]:1 }; console.log(Object.getOwnPropertyNames(obj)); console.log(Object.getOwnPropertySymbols(obj)); console.log(Reflect.ownKeys(obj)) // 6) Reflect.setPrototypeOf Reflect.getPrototypeOf // 7) 函数的apply方法 bind call apply的区别 改变this指向 const fn = function(a,b){ // apply 支持多个参数传参 console.log(this,a,b); } fn.apply = function(){ console.log('apply') } // 函数原型上的apply方法 让他执行 // call 的特点 1） 是改this指向 让函数执行 // Function.prototype.apply.call(fn,1,[2,3]); Reflect.apply(fn,1,[2,3]); // 用原型上的apply方法 class XXX{ constructor(name){ this.name = name } } let xxx = Reflect.construct(XXX,['zf']); console.log(xxx); // new Reflect.deleteProperty // delete obj.a 返回是否删除成功 let obj = {}; // 扩展不能添加属性 Reflect.preventExtensions(obj) obj.a = 1; console.log(Reflect.isExtensible(obj)); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 15:01:23 "},"web/es6/set&map.html":{"url":"web/es6/set&map.html","title":"set&map","keywords":"","body":" import { log } from \"util\"; { // new Set():声明set数据结构 let list = new Set(); list.add(5) list.add(7) console.log('size',list.size) // size 2 } { // set中放入数组 let arr = [1,2,3,4,5] let list = new Set(arr) console.log('szie',list.size) // size 5 } { // set中数据的唯一性 let list = new Set() list.add(1) list.add(2) list.add(1) console.log('list',list) //{1, 2} let arr = [1,2,3,4,'2']; let list2 = new Set(arr) console.log('unique',list2); // {1, 2, 3, 4, \"2\"} } { //list.has():判断set结构中是否包含 let arr = ['add','delete','clear','has']; let list = new Set(arr) console.log('has',list.has('add')); // has true console.log('delete',list.delete('add'),list); // delete true {\"delete\", \"clear\", \"has\"} list.clear(); // 清空set数据结构 console.log('list',list); // list {} } { // set数据遍历的方法 let arr = ['add','delete','clear','has']; let list = new Set(arr) for(let key of list.keys()){ console.log('keys','key') // keys key } for(let value of list.values()){ console.log('value',value) // value add value delete value clear value has } for(let [key,value] of list.entries()){ console.log('entries',key,value); // entries add add entries delete delete entries clear claer entries has has } list.forEach(function(item){console.log(item); // add delete clear has }) } { // 声明weakSeet数据结构 // weakSet的成员只能是对象 // weakSet不能被遍历 // weakSet的对象是弱引用，如果其他对象都不再引用该对象 // 那垃圾回收机制会自动回收该对象所占的内存 let weakList = new WeakSet(); let arg = {} weakList.add(arg) console.log(weakList); } { // map.get():获取map数据结构的值 let map = new Map() let arr = ['123'] map.set(arr,456) console.log('map',map,map.get(arr)) } { // 声明map的key和value的 let map = new Map([['a',123],['b',456]]) console.log('map args',map); console.log('size',map.size); console.log('delete',map.delete('a'),map); console.log('clear',map.clear(),map); } { // 声明weakMap的数据结构 let weakmap = new WeakMap() let o = {} weakmap.set(o,123) console.log(weakmap.get(o)); } { let map = new Map() // map.set() map.set('t','1') console.info('map.set()',map) // map的获取 console.log('map.get()',map.get('t')); // 遍历map的数据结构 for(let [key,value] of map.entries()){ console.log('map.entries()',value) } // map.has() console.log('map.has()',map.has('t')) // 获取map的长度 console.log('map.size',map.size); // map.delete() map.delete('t') // map.clear() map.clear() } // 优先使用map这种数据结构，考虑数据的唯一性，考虑set { //map,set,Object对比 let item = {t:1} let map = new Map() let set = new Set() let obj = {} // 增 map.set('t',1) set.add(item) obj['t'] = 1; console.log('map-set-obj',map,set,obj); // 查 console.log('map_exist',map.has('t')); console.log('set_exist',set.has(item)); console.log('map_exist','t' in obj); // 改 map.set('t',2) item.t = 2 obj['t'] = 2 console.log('map-set-obj-modify',map,set,obj); // 删 map.delete('t') set.delete(item) delete obj['t'] console.log('map-set-obj-delete',map,set,obj); } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:55:08 "},"web/es6/string&Method.html":{"url":"web/es6/string&Method.html","title":"string&Method","keywords":"","body":" { console.log('a','\\u0061') //a ,a // 因为表示法仅限于码点在\\u0000~\\uFFFF当中，超出只能通过双字节来表示 \\uD842\\uDFB7 console.log('s',`\\u20BB7`) // s ₻7 console.log('s',`\\u{20BB7}`) // s 𠮷 } { // js中字符已UTF-16格式存储，每个字符固定两个字节，对于那些 // 需要四个字符存储的字符，js会认为是两个字符 let s = '𠮷' ; console.log('length',s.length) // length 2 console.log('0',s.charAt(0)) // 0 � console.log('1',s.charAt(1)) // 1 � console.log('at0',s.charCodeAt(0)) // at0 55362 console.log('at1',s.charCodeAt(1)) // at1 57271 let s1 = '𠮷a'; console.log('length',s1.length); //3 console.log('code0',s1.codePointAt(0)) //code0 134071 console.log('code0',s1.codePointAt(0).toString(16)) //code0 20bb7 console.log('code1',s1.codePointAt(1)) //code1 57271 console.log('code2',s1.codePointAt(2)) //code2 97 } { // 使用该方法从码点返回对应的字符串 console.log(String.fromCharCode('0x20bb7')) //ஷ // 相比上一个方法可以识别大于0xFFFF的码点 console.log(String.fromCodePoint(\"0x20bb7\")); //𠮷 } { let str = '\\u{20bb7}abc' for (let index = 0; index Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 11:10:43 "},"web/es6/symbol.html":{"url":"web/es6/symbol.html","title":"symbol","keywords":"","body":" // 数据类型 string number boolean null undefined // Symbol 独一无二 // 用作常量 const s1 = Symbol(\"zf\"); // number or string const s2 = Symbol(\"zf\"); console.log(s1 === s2); // 属性私有化 let s1 = Symbol.for(\"zf\"); let s2 = Symbol.for(\"zf\"); // 如果symbol已经有值了 就将这个值返回即可 console.log(s1 === s2); console.log(Symbol.keyFor(s2)); let obj = { [s1]: 1 // es6写法 []含义是将s1 结果取出来作为key }; console.log(obj[s1]); // 不能使用.运算符 // 元编程 可以改变js源代码的功能 改变js原有的功能 // instanceof // 可以判断某个人是否是谁的实例 let o = { name: 1 }; // Symbol.iterator 在我迭代的时候 默认就会调用此方法 let obj = { // Object.defineproperty [Symbol.hasInstance]() { return \"name\" in o; } }; console.log(o instanceof obj); let obj = { [Symbol.toPrimitive](value) { console.log(value); return \"hello\"; }, a: 1 }; // valueOf toString console.log(obj * 1); // toString const obj = { get [Symbol.toStringTag]() { return \"123\"; } }; // Object.prototype.toString console.log(obj.toString()); // [object 123] // 衍生对象 class MyArray extends Array { constructor(...args) { super(...args); } static get [Symbol.species]() { return Array; // 控制衍生对象的类的构造函数 } } let myarr = new MyArray(1, 2, 3); let newArr = myarr.map(item => item * 2); // 衍生出来的结果是当前的实例 // instanceof 原理 .__proto__.__proto__ console.log(newArr instanceof MyArray); // split replace match search // with 我可以通过with 直接拿到with中的属性 // 我们可以声明一些属性 不在with中使用 console.log(Array.prototype[Symbol.unscopables]) with (Array.prototype) { fill(1,2,3) } class My{ eat(){} get [Symbol.unscopables](){ return {eat:true}; } } with(My.prototype){ console.log(eat); } let arr = [1,2,3]; arr[Symbol.isConcatSpreadable] = false; console.log(arr.concat(4,5,6)); // Symbol 11 reflect 13 } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 16:42:23 "},"web/es6/defineProperty.html":{"url":"web/es6/defineProperty.html","title":"defineProperty","keywords":"","body":" // Object.defineProperty getter setter let obj = { _a:'', get a(){ // todo ... return this._a }, set a(value){ this._a = value } } obj.a = 100; console.log(obj.a); // 需要借用一个第三方变量来中转 // vue中数据劫持 给每个对象都添加一个 getter和setter 当值变化可以 可以实现更新视图的功能 let obj = {} let val = ''; Object.defineProperty(obj,'a',{ configurable:true, // 是否可删除 // writable:true, // 是否可写, enumerable:true, // for in 原型上的方法 get(){ return val }, set(value){ val = value; } // 默认设置的值是不可枚举的 }) delete obj.a console.log(obj); let obj = { a: 1, b: 2, }; // value 源码 function observer(obj) { // 缺陷就是无法监控数组的变化 if (typeof obj !== \"object\" || obj == null) { return; } for (let key in obj) { // 因为defineProperty 需要一个公共的值去修改 defineReactive(obj, key, obj[key]); } } let updateView = () => { // 更新方法 console.log(\"更新\"); }; // obj => {a:1,b:2} key=> a / b value = 1/2 function defineReactive(obj, key, value) { // Object.defineProperty observer(value); // 递归增加getter和setter Object.defineProperty(obj, key, { get() { return value; }, set(val) { updateView(); value = val; } }); } observer(obj); obj.a.a = 100; console.log(obj.a); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 11:21:32 "},"node/node.html":{"url":"node/node.html","title":"node 基础语法","keywords":"","body":" node 基础语法 常用：中间层 服务端渲染 脚本 特点 单线程非阻塞 IO，这是由 javaScript 这门脚本语言的用途决定的 浏览器的 ui 线程和 js 的线程共用一个线程 webWorker 并没有改变单线程的特点 1.完成受主线程的控制(附庸关系) 2.不能操作 Dom 除了 JS 线程和 UI 线程之外的其他线程 浏览器事件触发线程 定时触发器线程 异步 HTTP 请求线程 进程和线程的区别 同步和异步关注的是消息的通知方式 同步异步是由调用方决定，他来决定是马上给你答案，还是回头再给 阻塞非阻塞是由调用方来决定，在等待答案的过程，调用方可以干别的事 repl 就是 Node 的窗口容器 .break 退出当前的代码编写块 .clear 清楚当前上下文 .save (.save num.log) 保存当前的代码生成文件 console console.time() console.timeEnd():用来计算代码的执行时间 console.time(\"time\") var i=0; while(i++ console.assert() 断言 TDD 测试驱动开发 BDD 行为驱动开发 // 断言 function sum(a,b){return a+b} console.assert(sum(1,2) == 4,'报错') console.dir():可以列出对象的解构 let a = {a:123,home:{name:'beijing'}} console.dir(a) console.trace():可以列出对象的解构 console.trace() global process console.log(process) fs 模块 const fs = require('fs') // 判断文件是否存在，不存在则抛出异常 fs.accessSync('./1.js') path 模块 const path = require('path'); // __dirname：获取当前的路径 // /Users/changcheng/Downloads/test console.log(__dirname) // path.resolve()：获取当前文件的绝对路径 // /Users/changcheng/Downloads/test/1.js console.log(path.resolve(__dirname, '1.js')) // path.join():拼接路径 // /Users/changcheng/Downloads/test/bar/1.js console.log(path.join(__dirname, '/bar/1.js')) // path.extname():获取文件后缀 // .js console.log(path.extname('1.js')) // path.basename():路径过滤 // 1. console.log(path.basename('1.js', 'js')) // path.dirname():取当前路径的父路径 // /Users/changcheng/Downloads console.log(path.dirname(__dirname)) vm 虚拟机模块 // error b is not defined const vm = require('vm') let b = 1; vm.runInThisContext(`console.log(b)`) require 原理 // 路径模块 const path = require('path'); // 文件模块 const fs = require('fs'); // 沙箱 const vm = require('vm'); function Module(absPath){ this.id = absPath; this.exports = {}; } const wrapper = [ // module 和 exports 是什么关系? '(function(exports,module,require){', '})' ] Module.prototype.load = function(){ let script = fs.readFileSync(this.id,'utf8'); let fnStr = wrapper[0] + script + wrapper[1]; let fn = vm.runInThisContext(fnStr); fn(this.exports,this,req); // 让拼出的函数执行 } function req(file){ // ./a // 1) 把当前这个文件读取出来 把相对路径转化成绝对路径 let absPath = path.resolve(__dirname,file); // 加载一个模块 模块就是要有一个exports属性 // 2) 创建一个模块 let module = new Module(absPath); // 创建了一个模块 // 3) 加载模块 module.load(); return module.exports } let a = req('./a.js'); console.log(a); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 11:05:11 "},"node/":{"url":"node/","title":"常用架构","keywords":"","body":" koa2 基础架构 koa-generator 异步库 npm install -g koa-generator 安装 koa2 模板 koa2 -e name koa2 项目所需插件 cross-env node 本地环境变量 安装 mysql 版本 5.7.23 安装 mysqlworkbench 可视化工具 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 11:05:05 "},"node/mysql.html":{"url":"node/mysql.html","title":"mysql","keywords":"","body":"mySql mySql常用命令 // 查看所有的数据库 show databases; // 查看某个数据库 use databaseName; // 查询某个表 select * from tableName; // 查看users表的某几个字段 select username,nickname from users; // 往user表中添加数据(password是关键词) insert into users(username,`password`,nickname)values('zhangsan','123','张三'); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"node/redis.html":{"url":"node/redis.html","title":"redis","keywords":"","body":"redis基础 安装 // 启动redis服务 redis-server; // redis命令行操作 redis-cli; // 设置/修改值 set name 'changcheng' // 获取值 get name // 获取所有的key keys * // node安装redis插件 npm i redis -D Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"node/token.html":{"url":"node/token.html","title":"tooken/session/cookie","keywords":"","body":" tooken/session/cookie的区别 jwt vs session // 引入koa-jwt插件 const jwtKoa = require('koa-jwt') const jwt = require('jsonwebtoken') const verify = util.promisify(jwt.verify) // 设置加密算法的秘钥以及不校验的登录接口 app.use(jwtKoa({ secret:'secret' }).unless({ path: [/^\\/users\\/login/] })) // 登录接口返回token，有效时间一小时，由客户端进行存储 router.post('/login', async (ctx, next)=> { let SECRET = 'secret' let token = jwt.sign('result',SECRET, {expiresIn:'1h'}) } ctx.body = { errCode:0, data:token } } }) // 获取请求头中的token解密就是用户的信息 router.get('/getUserInfo', async (ctx, next)=> { const token = ctx.header.authorization try{ const payload = await verify(token.split(' ')[1],SECRET) ctx.body = { errno:0, userInfo:payload } }catch(err){ console.log('err',err) ctx.body = { errno:1, masg : 'verify token failed' } } }) 为了解决：登录&存储登录用户的信息 jwt用户信息加密存储在客户端，不依赖cookie，可跨域 session用户信息存储在服务端，依赖cookie，默认不可跨域 一般情况下，两者都能满足，大型系统中两者可共用 jwt更适合服务多的节点，跨域多的系统 session更适合统一的web服务，server要严格管理用户信息 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-02 16:02:19 "},"web/typeOf/":{"url":"web/typeOf/","title":"隐式类型转换","keywords":"","body":" 隐式类型转换 1.隐式类型转换规则 转换成 string 类型 + ,转换成 number 类型：++/--(自增自减运算符) + - * / %(算术运算符) > = 转换成 boolean 类型 !(逻辑非运算符) 字符串与算术运算符隐式转换规则混淆 字符串连接符:会把其他的数据类型调用 String()转成字符串然后进行拼接 算数运算符:会把其他的数据类型调用 Number()方法转换成数字然后做加法计算 // + 是字符串连接:String(1)+'true' console.log(1+\"true\") // 1true // + 是算数运算符:1+Number(true) = 2 console.log(1+true) // 2 // + 是算数运算符:1+Number(undefined) = NaN console.log(1+undefined) //NaN // + 是算术运算符:1+Number(null) = 1 console.log(1+null) // 1 // + 是算数运算符:1+Number([]) = 1 console.log(1+[]) // 1 // + 是算数运算符:1+Number({}) = NaN console.log(1+{}) // NaN 3.关系运算符：会把其他数据类型转换成 number 再进行比较 // 当关系运算符两边一边是字符串，会将其他数据类型用Number转换，然后再进行比较 console.log(\"2\" > 10) // false // 两边都是数字都是字符串的时候使用unicode编码来转换成数字 console.log(\"2\" > \"10\") // true // 多个字符从左到右依次比较 console.log(\"abc\" > \"b\") //false // 比较aa然后b>a console.log(\"abd\" > \"aad\") // true // 特殊情况无视规则 console.log(undefined == undefined) //true console.log(undefined == null) //true console.log(null == null) //true console.log(NaN == NaN) // false 4.复杂数据类型 复杂数据先使用 valueOf 方法获取其原始值，如果原始值不是 number 类型，则使用 toString()类型转成 string,再将 string 转成 number // 先将左边数据转成string，然后右边也是string则转成unicode编码运算 console.log([1,2] == '1,2') var a = {} console.log(a == '[object Object]') console.log(a.valueOf().toString()) //[object Object] 5.逻辑非隐式转换与关系运算符隐式转换搞混淆 关系运算符:将其他数据类型转换成数字类型 逻辑非：将其他数据类型转换成 Boolean 类型 八种数据类型转换为 Boolean 类型会得到 false [0,-0,NaN,undefined,null,\"\",false] //原理：[].valueOf().toString() 得到空字符串 Number(\"\") == 0 console.log([] == 0) // true //原理：！运算符优先级高于关系运算符，![] == false (空数组布尔值得到true，然后取反得到false), false == 0 console.log(![] == 0) //true //原理：本质上是空对象{} 与 !{}这个逻辑非表达式结果做比较 {}.valeOf().toString()得到字符串\"[object Object]\" !{} = false Number(\"[object Object]\") == Number(false) console.log({} == !{}) //false // 引用类型数据存在堆中，栈中存储的是地址，所以结果是false console.log({}=={}) // false console.log([]==[]) //false 引用类型和值类型的工作原理 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-23 15:23:42 "},"web/prototype/":{"url":"web/prototype/","title":"原型链","keywords":"","body":" 原型链 // Es5 中没有类 用构造函数模拟类 // 类中有两种属性 1）实例上的属性 2）公共属性 function Animal(){ if(! (this instanceof Animal)){ throw new Error('不是继承与该构造函数') } this.name = {name:'zf'} this.ages = 10 } Animal.prototype.say = function(){ console.log('sy') } let a1 = new Animal() let a2 = new Animal() 1.创造对象的几种方法 var a = {obj:3} function Demo(){ this.name = '3' } var demo = new Demo() var c = {c:3} var newObj = Object.create(c) 原型链的 instanceof 一个构造函数的 prototype 属性所指向的对象是否存在另外一个要检测对象的原型链上 function A(){ this.name = 'this is a' } var m = new A() console.log(m instanceof A) // 手动实现instanceOf function _instanceOf(protoObj,newFun){ var funPrototype = newFun.prototype; var __proto__ = protoObj.__proto__ if(__proto__ === null){ return false } if(__proto__ === funPrototype){ return true } return false } var Object = {} var result = _instanceOf(Object,A) console.log('result',result) new 运算符实现原理 // 第一步实现原型链的关联，可以通过原型链进行查找 // 第二部就是改变this指向拿到内部的属性 function fn(name){ this.name = '123' } function newFun(fn){ // es6方法，关联原型链 var o = Object.create(fn.prototype); var k = fn.call(o,arguments) if(k === 'object'){ return k }else{ return o } } var res = newFun(fn) console.log(res.name) JS 类与继承 类的继承 function Animal() { this.type = '哺乳类' } Animal.prototype.say = function() { console.log('动物原型链的方法') } function Tiger() { this.name = '老虎' Animal.call(this) } // 原型链混乱也就是原型链共享不推荐 // Tiger.prototype = Animal.prototype // 自己找不到向上找 // Tiger.prototype.__proto__ = Animal.prototype // Es6指定了链的指向 // Object.setPrototypeOf(Tiger.prototype, Animal.prototype) // 唯一有些不同的是，他在中间加了一层 Tiger.prototype = Object.create(Animal.prototype, { constructor: { value: Tiger } }) let tiger = new Tiger() console.log(tiger.type) tiger.say() Object.create 的实现原理 function create(parentPrototype){ function Fn() fn.prototype = parentPrototype let fn = new Fn() fn.constructor = Tiger } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-27 10:08:02 "},"web/curring.html":{"url":"web/curring.html","title":"函数柯里化","keywords":"","body":" 函数柯里化 柯里化的常用场景 // 正常验证字符串 function check(reg,txt){ return reg.text(txt) } check(/\\d+/g,'text') check(/[a-z]+/g,'text') // 柯里化 function curringCheck(reg){ return function(txt){ return reg.test(txt) } } let hasNumber = curringCheck(/d+/g) let hasNumber = curringCheck(/[a-z]+/g) hasNumber('test1') hasLetter('test1') bind // 分析：这里的bind方法会把第一个实参绑定给f函数内的this，所以这里的this指向{x:1}对象 // 从第二个参数起，会依次传递给原始函数，这里的第二个参数2即是f函数的y参数 // 最后调用m(3)的时候，这里的3便是最后一个参数z了，所以执行1+2+3 = 6 // 分步处理参数的过程就是一个典型的函数柯里化的过程 function f(y, z) { return this.x + y + z } let result = f.bind({ x: 1 }, 2)(3) console.log(result) // 3 const curring = (fn,arr = [])=>{ let len = fn.length; return (...args)=>{ arr = arr.concat(args) if(arr.length { return Object.prototype.toString.call(content) === `[object ${isString}]` } } let arr = [\"String\",\"Number\",\"Boolean\"] let utils ={} arr.forEach((type)=>{ utils[`is${type}`] = curring(checkTpye)(type) }) console.log(utils.isString('123')) function checkTpye(isString){ return (content)=>{ return Object.prototype.toString.call(content) === `[object ${isString}]` } } let arr = [\"String\",\"Number\",\"Boolean\"] let utils ={} arr.forEach((type)=>{ utils[`is${type}`] = checkTpye(type) }) console.log(utils.isString(\"123\")) } bind 的实现原理 Function.prototype.my_bind = function() { const self = this const context = [].shift.call(arguments) const args = [].slice.call(arguments) return function() { self.apply(context, Array.prototype.concat.call(args, [...arguments])) } } function demo(y, p) { console.log(this.x, y, p) } console.log(demo.my_bind({ x: 1 }, 2)(3)) 经典 add 函数 function add() { let args = Array.prototype.slice.call(arguments) let _add = function() { args.push(...arguments) return _add } // 利用隐式类型转换，最后一次执行的时候返回值 _add.toString = function() { let result = args.reduce((prev, current) => { return prev + current }) return result } return _add } console.log(add(1)(2)(3) == 6) console.log(add(1, 2, 3) == 6) console.log(add(1, 2)(3) == 6) const add = (a,b,c,d,e)=>{ return a+b+c+d+e } // 经典的函数柯里化 const curring = (fn,arr = [])=>{ let len = fn.length; return (...args)=>{ arr = arr.concat(args) if(arr.length Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-12 19:00:07 "},"web/fun/":{"url":"web/fun/","title":"发布订阅/高阶函数","keywords":"","body":" 高阶函数 发布订阅 let fs = require('fs') let school ={} let e = { //订阅 arr:[], on(fn){ this.arr.push(fn) }, // 发布事件 emit(){ this.arr.forEach((item)=>{ item() }) }, } // 订阅事件 e.on(()=>{ console.log(\"ok\") }) e.on(()=>{ if(Object.keys(school).length === 2){ console.log(school) } }) fs.readFile('./data/name.txt','utf8',(err,data)=>{ school[\"name\"] = data; e.emit(); }) fs.readFile('./data/age.txt','utf8',(err,data)=>{ school[\"age\"] = data; e.emit(); }) 观察者 class Subject{ constructor(){ // 存放观察者 this.arr = [] this.state = '开心' } chageState(newState){ this.state = newState this.arr.forEach(item=>{ item.update(this.state) }) } attach(o){ this.arr.push(o) } } class Parent{ constructor(name){ this.name = name } update(state){ console.log(this.name+'的小宝宝:'+state) } } let child = new Subject() let observer = new Parent(\"父亲\") let observer1 = new Parent(\"母亲\") child.attach(observer) child.attach(observer1) child.chageState('不开心了') 函数的 bfore AOP 切片 装饰，希望将核心逻辑拆分出来吗，在外面增加功能 Function.prototype.before = function(bfroreFn){ return (...arg)=>{ // 箭头函数没有this指向，所以会向上级作用域查找 bfroreFn(); this(...arg); } } function say(...arg){ console.log(\"arg:\",arg) } const newSay = say.before(()=>{ console.log(\"新增加的方法\") }) newSay(1,2,3,4) // js模拟事务 let perform = ((fn,wrappers)=>{ wrappers.forEach(element => { element.initlizae(); }); fn(); wrappers.forEach(element => { element.close(); }); }) perform(()=>{ console.log(\"say\") },[{ initlizae(){ console.log(\"hello\") }, close(){ console.log(\"bye\") } }]) compose:组合函数 function sum(a, b) { return a + b } function len(str) { return str.length } function addCurrency(val) { return `$${val}` } function compose(...fn) { return function(...nums) { let r = fn.pop() return fn.reduceRight((prev, current) => { return current(prev) // return current(prev(...nums)) }, r(...nums)) } } // reduex版本的compose function compose(...args) { return args.reduce((prev, current) => { return function(...values) { return prev(current(...values)) } }) } console.log(compose(addCurrency, len, sum)('abc', 'cbd')) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-09 15:23:11 "},"web/eventLoop/eventLoop.html":{"url":"web/eventLoop/eventLoop.html","title":"js 线程","keywords":"","body":" EventLoop 什么是进程什么是线程 进程是系统进行资源分配和调度的一个独立单位，一个进程内包含多个线程 渲染进程 GUI 渲染线程(页面渲染) js 引擎线程(执行 js 脚本) 事件触发线程(eventLoop 轮询线程) 事件(onClick)，定时器(setTimeout),ajax(xhr)(独立线程) 我们所谓的 js 为什么是单线程 一个线程在某个 dom 节点上添加内容，另一个线程删除了这个节点，那以哪个为准？ eventLoop 在一个时间循环当中，异步事件返回的结果会放到一个任务队列当中，然后宏任务放宏任务队列，微任务放微任务队列 我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。在当前的微任务没有执行完成时，是不会执行下一个宏任务的。 console.log(1); // 输出1 setTimeout(function() { // 添加到宏任务 macrotask:[console.log(2)] console.log(2); }, 0); new Promise(function(resolve) { // 输出3 console.log(3); resolve(Date.now()); }).then(function() { console.log(4); // 添加到微任务 microtask:[console.log(4)] }); console.log(5); // 输出 5 setTimeout(function() { new Promise(function(resolve) { // 添加到宏任务 macrotask:[console.log(2),newPromise...] console.log(6); }).then(function() { console.log(7); }); }, 0); // 输出 1 3 5 4 2 6 setTimeout(()=>{ console.log(1) },0) new Promise((resolve)=>{ resolve() }).then(()=>{ console.log(2) }) // 输出 2 1 setTimeout(_ => console.log(4)) new Promise(resolve => { resolve() console.log(1) }).then(_ => { console.log(3) Promise.resolve().then(_ => { console.log('before timeout') }).then(_ => { Promise.resolve().then(_ => { console.log('also before timeout') }) }) }) console.log(2) // 输出 1 2 3 before timeout also before timeout 4 JS 运行机制 console.log(1) setTimeout(function(){ console.log(3) },0) console.log(2) // 输出 1,2,3 for(var i=0 ;i eventLoop 所有同步任务都在主线程上执行，形成一个执行栈， 主线程之外,还存在一个任务队列，只要异步任务有了结果,就在任务队列中放置一个事件 一旦执行栈中所有的同步任务执行完毕,系统就会读取任务队列，看看里面有哪些事件,那么对应的异步任务,于是结束等待状态,进入执行栈,开始执行 主线程不断重复上面三步 如何开启异步事件队列 setTimeout 和 setInterval DOM 事件 Promise 宏任务和微任务 微任务:promise.then MutationObserver 宏任务:script,ajax,事件,requestFrameAnimation,setTimeout,setInterval,setImmediate,MessageChannel,UI,rendering 浏览器的 eventLoop 和 node 11 版本的表现一致 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 10:50:52 "},"web/jsonp/":{"url":"web/jsonp/","title":"跨域","keywords":"","body":"多种跨域方案详解 同源策略 协议 域名 端口 一致 为什么浏览器不支持跨域 cookie LocalStorage都具有同源限制，防止cookie共享带来的安全性 // 跨域强制携带cookie xhr.withCredentials = true 实现跨域的几种方式 1. jsonp 缺点：1.只能发送get请求 2.容易遭受xss攻击 JSONP实现 // jsonp的实现 function jsonp({url,params,cb}){ return new Promise((resolve,reject)=>{ let script = document.createElement('script'); // 获取函数中的参数 window[cb] = function(data){ console.log(\"data\",data) resolve(data) document.removeChild(script) } params = {...params,cb} let arrs = [] for(let key in params){ arrs.push(`${key}=${params[key]}`) } script.src = `${url}?${arrs.join('&')}` document.body.appendChild(script) }) } jsonp({ url:'https://www.baidu.com/sugrec', params:{wd:'b'}, cb:'jQuery11020574908' }).then(data=>{ console.log(data) }) 2. cors 最常用的方式，后端设置Access-Control-Allow-Origin // 伪代码 let express = require('express'); let app = express() let whitList = ['http://www.baidu.com'] app.use((req,res,next)=>{ let origin = req.headers.origin; if(whitList.includes(origin)){ res.setHeader('Access-Control-Allow-Origin',origin) // 设置允许跨域携带cookit res.setHeader('Access-Control-Allow-Credentials',true) // 设置6秒之内不会发送options请求 res.setHeader('Access-Control-Max-age',6) // 支持headers中的name属性 res.setHeader('Access-Control-Expose-Headers','name') // 三种情况会出现预请求 // 1.请求的方式不是GET/POST/HEAD // 2.POST的请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain // 3.请求设置了自定义header if(req.method == 'options'){ res.send() } } }) 3. postMessage // A页面 function load(){ let frame = document.getElementById('frame'); frame.contentWindow.postMessage('传递给B页面的内容','http://localhost:4000'); } //监听B页面传递过来的消息 window.onmessage = function(e){ console.log(e.data); e.source.postMessage('我拒收了b页面的消息'，e.origin) } // B页面 window.onmessage = function(e){ console.log(e.data); e.source.postMessage('我拒收了A页面的消息'，e.origin) } 4. document.domain document.domain：返回当前文档的服务器域名 前提条件:这两个域名必须属于同一个基础域名，而且所用协议，端口都必须一致，否则无法使用documeng.domain进行跨域 前提条件满足之后利用document.domain设置为同一个一级域名就可以实现跨域 // 一级域名 http://www.baidu.com // 二级域名 http://movie.baidu.com // A页面 document.domain = 'zf1.cn' function load(){ var iframe = document.getElementById('frame'); console.log(iframe.contentWindow.a) } // B页面 document.domain = 'zf1.cn' var a = '123' ` 5. window.name // A和B是同域的 // C是不同域的 // a先获取C的数据 c把值放在window上面，然后把a的引用地址改到B,这样的话name不会消失 let first = true function load(){ if(first){ let iframe = document.getElementById('frame'); iframe.src = 'http://localhost:3000/b.html' first = false }else{ console.log(iframe.contentWindow.name) } } 6. locaiton.hash // 路径后面的hash值可以用来通信 // 目的是a想访问C,a和b页面是同源的 // a给c传一个hash值，c收到hash值后，C把Hash值传递给B，b将结果放到a到hash值中 // A页面 window.onhashchange = function(){ console.log(locaiton.hash) } // B页面 // 设置a页面的hash值，触发a页面的onhashchange方法拿到hash值 window.parent.parent.location.hash = location.hash // C页面 console.log(location.hash) // 这里可以获取A页面传递过来的hash值 let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe) 7. http-proxy 常见项目当中的解决跨域问题就是配置proxy使用的就是http-proxy-middleware插件 8. nginx 高性能的HTTP和反向代理的服务器 9. websocket websocket和Http协议的区别 websocket是双向连接，Http是单向连接 // web var ws = new WebSocket(\"wss://echo.websocket.org\"); // 建立连接，发送消息 ws.open = function(evt){ console.log(\"Connection open ...\"); ws.sned(\"This is message\"); } // 监听收到的消息 ws.onmessage = function(evt){ console.log(\"Recived Message:\"+evt.data) ws.close() } // 监听关闭 ws.onclose = function(evt){ console.log(\"connection closed\") } // node let express = require('express'); let app = express(); let webSocket = require('ws'); let wss = new webSocket.Server({prt:3000}); wss.on('connection',function(ws){ wss.on('message',function(data){ console.log(\"data\",data) ws.end('发送给客户端的消息') }) }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-16 11:32:39 "},"web/arr/":{"url":"web/arr/","title":"数组方法","keywords":"","body":"常用数组方法 Array.of() Array.prototype.concat() Array.prototype.copyWithin() Array.prototype.entries() Array.prototype.every() Array.prototype.fill() Array.prototype.filter() Array.prototype.find() Array.prototype.findIndex() Array.prototype.flat() Array.prototype.flatMap() Array.prototype.forEach() Array.prototype.includes() Array.prototype.indexOf() Array.prototype.join() Array.prototype.keys() Array.prototype.lastIndexOf() Array.prototype.map() Array.prototype.pop() Array.prototype.push() Array.prototype.reduce() Array.prototype.reduceRight():区别于reduce是从右往左进行操作 Array.prototype.reverse() Array.prototype.shift() Array.prototype.slice() Array.prototype.some() Array.prototype.sort() Array.prototype.splice() Array.prototype.toLocaleString() Array.prototype.toString() Array.prototype.unshift() Array.prototype.values() Array.from() Array.isArray():结果返回true/false Array.reduce((prev,next,currentIndex,arr)={},initalValue) prev:初始值(必须) next:当前元素(必须) currentIndex:当前元素的索引(可选) arr:当前元素对象(可选) initalValue:当前元素对象(可选) // 数组求和 const arr = [1,2,3,4,5] const total = arr.reduce((prev,next)=>{ console.log(prev,next) return prev + next // return之后会改变下次的total },0) // 0 1 // 1 2 // 3 3 // 6 4 // 10 5 // 数组合并 const arr = [[1,2],[3,4],[5,6]]; const total = arr.reduce(function(newArr,itemArr){ return newArr.concat(itemArr) }, []); console.log('======total',total); //[1, 2, 3, 4, 5, 6] const arr = [\"aaa\", \"bbb\", \"ccc\"]; arr.reduce(function(prev,next){ console.log(\"prev:\",prev); console.log(\"next:\",next); return prev; // prev: 111 },'111'); // next: aaa // prev: 111 // next: bbb // prev: 111 // next: ccc Array.join() 将数组转化为字符串 var arr = [1,2,3,4] arr.join() // 1,2,3,4 arr.join('') // 1234 Array.slice(start,end) start:开始下标 end:结束下标 截取数组，不会改变改变原数组 var arr = [1,2,3,4] arr.slice(0,1) // 返回:[0,1] var arr1 = [1,2,3,4] arr1.slice() // 返回：[1,2,3,4] var arr2 = [1,2,3,4,5,6] arr2.slice(2,4) // 返回 [3,4] Array.splice(index,deleteMany,item1,...itemX) 截取数组，向数组添加元素，该方法会改变原数组 index:开始位置 deleteMany:删除的数量 item1,...itemX: 添加的项 var arr = [1,2,3,4] arr.splice(0,1,9) // 原数组：[9,2,3,4] 返回[1] var arr1 = [1,2,3,4] arr1.splice(0,1) // 原数组：[2,3,4] 返回:[1] var arr2 = [1,2,3,4,5,6] arr2.splice(2,4) // 返回：[3,4,5,6] Array.from() 该方法用于将两类对象转换成真正的数组：类数组的对象和可遍历对象 可以接受一个参数来对数组当中的每个元素进行单独处理 var obj = { 0:123, length:1 // length为必选项 } Array.from(obj) // 返回 [123] // 如果是ES5的实现 Array.prototype.slice.call(obj) //[123] // 传入函数针对每个参数进行单独处理 var arr = [1,false,false,4] Array.from(arr,(x)=>{ return x ? x : true // 返回[1,true,true,4] }) Array.of() 该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型 Array.of(1,2) // 返回[1,2] Array.of(undefined) // 返回[undefined] // ES5实现 function ArrayOf(){ return [].slice.call(arguments); } Array.copyWithin(target,start,end) target:从该位置替换数据，负值就是倒数 start:从该位置开始读取数据，默认为0，负值，从末尾开始计算 end:到该位置停止读取数据 // 将3号位复制到0号位 [1,2,3,4,5].copyWithin(0,1,2) // [2,2,3,4,5] [1,2,3,4,5].copyWithin(0,-2,-1) // [4,2,3,4,5] [1,2,3,4,5].copyWithin(1,3,4) // [1,4,3,4,5] Array.find()和Array.findIndex() 区别：Array.find()是返回符合条件的第一个成员 Array.findIndex()是返回符合条件成员的位置 // Array.find() [1,2,3,4,5].find((val)=>{ val>3 // 4 }) // Array.findIndex() [1,2,3,4,5].findIndex((val)=>{ val>3 // 3 }) // 这两个方法都可以接口第二个参数，用来绑定回调函数的this对象 function f(v){ return v > this.age } var obj = { age:20 } [19,23,21].findIndex(f,obj) // 返回：1 Arryay.fill(elem,start,end) elem:填充的数值(必填) start:开始填充的位置 end:结束的位置 [1,2,3].fill(4) // [4,4,4] [1,2,3].fill(9,2,3) // [1,2,9] entries(),keys(),values() // entreis() for(let [index,elem] of ['a','b'].entries()){ console.log(index,elem) // 0 'a' } // 1 'b' // keys() for(let elem of ['a','b'].keys()){ console.log(elem) // 0 1 } // values() for(let elem of ['a','b'].values()){ console.log(elem) // 'a' 'b' } Array.includes(elem,start) 判断数组里是否包含某项 返回true/false elem：查找的元素 start:起始位置 [1,2,3,4].includes(3) // true [1,2,3,4].includes(3,3) //false flat(),flatMap() flat():用来展开嵌套数组，会忽略空格会修改原数组 flatMap():flatMap 方法与 map 方法和深度depth为1的 flat 几乎相同. // flat():平铺数组 [1,[2,3,[4,5,[6]]]].flat(Infinity) // [1,2,3,4,5,6] // flatMap():可以忽略空格，map不忽略空格 let arr = [\"今天天气不错\", \"\", \"早上好\"] arr.map(s => s.split(\"\")) // [[\"今\", \"天\", \"天\", \"气\", \"不\", \"错\"],[],[\"早\", \"上\", \"好\"]] arr.flatMap(s => s.split('')); // [\"今\", \"天\", \"天\", \"气\", \"不\", \"错\", \"早\", \"上\", \"好\"] Array.map() 该方法创建一个新数组，结果是该数组中的每个元素调用一个函数返回的结果 var arr = [1,2,3,4] var newArr = arr.map(x=>{ return x * 2 }) console.log(newArr) //2,4,6,8 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"web/dom/":{"url":"web/dom/","title":"Dom","keywords":"","body":"常见的dom操作 操作dom的属性和方法 getElementById 上下文只能是document(只有document这个实例的原型链上才能找到，其他实例找不到) ID重复获取第一个 getElementsByTagName 获取上下文当中，所有子子孙孙的中标签叫xx的元素 getElementsByClassName 上下文只能是document querySelector 返回匹配的一个元素，没有返回Null querySelectorAll 返回符合条件的nodeList集合 document.documentElement 获取整个页面html结构 document.body document.heady 描述节点和节点之间关系的属性      nodeType    nodeName     nodeValue 元素节点    1      大写标签名     null 文本节点   3      #text       文本内容 注释节点   8      #comment     注释内容 文档节点   9      #document     null childNodes:所有子节点 children:所有元素节点 parentNode:父节点 previousSibling/previousElementSibling:前一个节点/前一个元素节点 nextSibling/nextElementSibling:下一个节点/下一个元素节点 firstChild/firstElementChild:第一个节点/第一个元素接地那 lastChild/lastElementChild:最后一个节点/最后一个元素节点 动态操作Dom document.createElement:创建一个dom节点 document.createElement('button') createDocumentFragment:创建一个虚拟节点对象 var d=document.createDocumentFragment(); d.appendChild(document.getElementsByTagName(\"LI\")[0]); d.childNodes[0].childNodes[0].nodeValue=\"Milk\"; document.getElementsByTagName(\"UL\")[0].appendChild(d); appendChild:添加一个子元素 var node=document.getElementById(\"myList2\").lastChild; document.getElementById(\"myList1\").appendChild(node); insertBefore:在...之前插入一个元素 document.getElementById(\"myList\").insertBefore(newItem,existingItem); cloneNode(true/false) true:复制当前所有的子孙节点 false:只复制当前的节点 var node=document.getElementById(\"myList2\").lastChild.cloneNode(true); document.getElementById(\"myList1\").appendChild(node); removeChild:移除一个节点 var list=document.getElementById(\"myList\"); list.removeChild(list.childNodes[0]); set/get/removeAttribute setAttribute:设置属性 document.getElementsByTagName(\"INPUT\")[0].setAttribute(\"type\",\"button\"); getAttribute:获取属性 document.getElementsByTagName(\"a\")[0].getAttribute(\"target\"); removeAttribute:移除属性 document.getElementsByTagName(\"H1\")[0].removeAttribute(\"style\"); dom.style.xxx = xxx xxx.stye.xxx :获取行内样式 xxx.className = '' :设置className的名称 xxx.onClick = function(){}:设置点击事件 JS盒子模型属性 在js中通过相关的属性可以获取(设置)元素的样式信息，这些属性就是盒子模型的属性 client(left/width/height) 1.clientWidth && clientHeight:获取可视区域的宽高(内容的宽高+padding的宽高)，不算内容溢出。 2.clientleft && clientTop:获取(左/上)边框的宽度 3.document.documentElement.clientWidth/clientHeight:获取当前屏幕的可视宽度/高度,随着拉伸而改变 4.document.body.clientWidth/clientHeight:不会随拉伸而改变 offset(top/left/width/height/parent) 1.offsetWidth && offsetHeight:在client的基础上加上border，不算内容溢出。 2.offsetTop:获取当前盒子元素外边框距离其父级参照参照物内边框的上偏移(不包含定位的情况是body) 3.offsetLeft:获取当前盒子元素外边框距离其父级参照参照物内边框的左偏移(不包含定位的情况是body) 4.offsetParent:同一个平面默认都是body 同一个平面默认参照物是body,body的父级参照物是Null,构建不同的平面用z-index，但是这个属性只对定位有作用，所以改变元素的定位可以改变父级参照物 scroll(top/left/width/height) 1.scrollWidth/Height:真实内容的宽高(可能溢出的值+padding) 2.scrollTop:静止状态或者没有滚动条值是0，垂直滚动条滚动的高度 3.scrollLeft:静止状态或者没有滚动条值是0，横向滚动条滚动的高度 4.document.documentElement.scrollHeight/document.documentElement.scrollWidth:获取当前页面真实的宽高 5.document.documentElement.scrollHeight/document.documentElement.scrollWidth:获取当前body真实的宽高 JS盒子模型属性 通过js盒模型属性获取值的特点 1.都是数字，不带单位 2.获取的都是整数，不会出现小数 3.获取的结果都是符合样式值，如果想获取单一样式(例如:只想获取padding样式)，我们的盒子模型属性就操作不了了 获取元素的单一样式值 1.dom.style.xxx 只能获取元素的行内样式 var dom = document.getElementById('outer'); dom.style.color //red 2.getComputedStyle(dom).height 只能获取元素的非行内样式 var dom = document.getElementById('outer'); getComputedStyle(dom).width //300px 获取元素的样式值 let getClass = function(curEl,attr){ if(window.getComputedStyle == undefined){ return } let val = window.getComputedStyle(curEl)[attr]; // 去除单位 reg = /^-?\\d+(\\.\\d+)?(px|rem|em|pt)?$/i reg.test(val) ? val = parseFloat(val) : null return val } 设置元素的样式值 //单独设置元素样式 let setClass = function(curEl,attr,val){ if(attr == 'opacity'){ curEl.style.opacity = val return } let reg = /^(width|height|fontSize|((margin|left)(top|left|right|bottom)?))$/i; reg.test(val) ? val +'px' :null curEl['style'][attr] = val } // 批量设置元素样式 let setGroupCss = function(curEl,options = {}){ // for in 循环只遍历当前对象可枚举的属性 for(let attr in options){ // 不获取在原型链上拓展的属性 if(options.hasOwnProperty(attr)){ setClass(curEl,attr,options[attr]) } } } setClass(dom,{ width:'200', height:'200', }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-11 10:04:18 "},"web/flex/":{"url":"web/flex/","title":"弹性盒子","keywords":"","body":" css盒模型 1.谈谈你对css盒模型的认识 盒模型包括：margin，padding，border，contenet 基本概念：标准模型+IE模型. 2.标准模型和IE盒模型的却别 标准模型的宽高指的是content内容的宽高 IE盒模型的宽高包含padding和border的宽高 3.css是如何设置这两种模型的 设置为标准盒模型：box-sizing:content-box; 设置为IE盒模型： box-sizing:border-box; 浏览器默认为content-box; 4.js如何设置获取盒模型对应的宽高 dom.style.width/height : 只能取内联样式的宽和高 dom.currentStyle.width/height ：获取的是渲染之后的结果(只能IE支持) window.getComputedStyle(dom).width/height ：兼容性比dom.currentStyle好 dom.getBoundingClientRect().width/height ：计算相对于视窗的绝对位置能拿到left/top/width/height 5.解释盒模型的边距重叠 通常情况下，如果给嵌套的子元素设置margin，就会产生对父元素也产生同样的效果，然后这并不是我们想要的效果，我们只想对子元素设置margin，那么我们应该怎么做呢 1.给父元素设置边框 2.给父元素添加padding 3.父元素设置overflow:hidden，相当于给父级创建了bfc，块级格式化上下文 4.给子元素设置inline-block(如果子元素是行内或者行内块级元素则不会产生边距的问题) 5.子元素脱离文本流(浮动，绝对定位,fixed) 6.BFC的概念： BFC决定了元素对其内容如何进行定位，以及与其他元素的关系和相互作用，具有BFC特性的元素可以看做是隔离了的容器，容器内的元素不会在布局上影响到外面的元素，可以理解为BFC为一个密闭的大箱子，箱子内的元素无论如何布局，都不会影响到外部 7.形成BFC的条件： body根元素 浮动元素：float除none的值 绝对定位元素：position:absolute/fixed display：inline-block,table-cells,flex overflow除了visible的值(hidden,auto,scroll) 8.BFC的作用 阻止外边距重叠，也就是块级标签竖直方向margin会以大的为准，也就是margin重叠，可以用overflow:hidden产生bfc解决 包含浮动元素 阻止元素被浮动元素遮盖 9.解决浮动子元素脱离父级文本流 overflow:hidden 弹性盒子 flex-direction:设置排列方式 justify-content:设置主轴方向的排列方式 align-items:设置纵轴方向的排列方式 flex-wrap:设置超出是否换行 align-content:设置行对齐 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-16 11:12:15 "},"web/string/":{"url":"web/string/","title":"字符串方法","keywords":"","body":"常用字符串方法 String.concat():字符串拼接 String.substr() String.substr(indexStart,indexEnd)不建议使用 indexStart:开始位置 indexEnd:截取的数量 var str = '123456' console.log(str.substr(2,3)) // 345 String.substring(indexStart,number) indexStart:开始下标 number:截取数量 var str = '123456789' console.log(str.substring(3,4)) // 4567 String.slice() var str = 'ThisisString' console.log(str.slice(3,5)) // si String.includes() String.startsWith() String.endsWith() includes():返回布尔值,是否找到了参数字符串 startsWith():返回布尔值,是否在头部找到了参数字符串 endsWith():返回布尔值,是否在尾部找到了参数字符串 var str ='Hello world!' // includes() console.log(str.includes(' wor')) //true // startsWith() console.log(str.startsWith('Hello')) //true // endsWith() console.log(str.endsWith('!')) //true String.repeat() 该方法返回一个新的字符串,表示将字符串重复N次 如果repeat的参数是负数或者Infinity，会报错 var str = '123' console.log(str.repeat(3)) // '123123123' trim String.trimStart() String.trimEnd() trim():从两端消除空格 trimStart():消除头部空格 trimEnd():消除尾部空格 都不会修改原字符串 const str = ' abc '; // trim() console.log(str.trim()) // 'abc' // trimStart() console.log(str.trimStart()) // 'abc ' // trimEnd console.log(str.trimEnd()) // ' abc' String.charAt() 从一个字符串中返回指定的字符 var anyString = \"Brave new world\"; console.log(\"The character at index 0 is '\" + anyString.charAt(0) + \"'\"); // The character at index 0 is 'B' console.log(\"The character at index 1 is '\" + anyString.charAt(1) + \"'\"); // The character at index 0 is 'r' console.log(\"The character at index 2 is '\" + anyString.charAt(2) + \"'\"); // The character at index 0 is 'a' console.log(\"The character at index 3 is '\" + anyString.charAt(3) + \"'\"); // The character at index 0 is 'v' console.log(\"The character at index 4 is '\" + anyString.charAt(4) + \"'\"); // The character at index 0 is 'e' console.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\"); // The character at index 0 is '' Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"web/nginx/":{"url":"web/nginx/","title":"nginx","keywords":"","body":"nginx详解 nginx是一个开源而且高性能的、可靠的HTTP中间件和代理服务器 关闭iptables iptables命令是Linux上最常用的防火墙软件 停止防火墙: systemctl stop firewalled.service 永久关闭防火墙: systemctl disable firewalled.service 确认停用selinux 安全增强型的linux，是一个linux的内核模块，也是linux的一个安全子系统 停止:setenforce 0 安装linux所需模块 yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake yum -y install wget httpd-tools vim nginx的优势 IO多路复用 多个描述符的IO操作都能在一个线程里并发交替顺序完成，复用多线程 select线程(类似于轮询是否完成):线性遍历文件描述符列表1.效率低下2.最多只有1024 epoll(nginx模型):每当fd就绪，采用系统回调函数将fd放下1.效率高2.没有1024限制 编写linux配置 vi /etc/yum.repos.d/nginx.repo [nginx] name=nginx repo baseurl = http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0 enabled=1 安装nginx yum install nginx Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"web/regExp/":{"url":"web/regExp/","title":"正则","keywords":"","body":"正则详解 每一个正则都是由\"元字符\",\"修饰符\",两部分组成 正则两个斜杠之间包起来的都是\"元字符\" 斜杠后面出现的都是\"修饰符\" 创建正则的两种方式 let reg1 = /^\\d+$/g; //字面量 let reg2 = new RegExp(\"^\\\\d+$\",\"g\") //构造函数方式 常用的修饰符 i:ignoreCase 忽略大小写匹配 m:multiline 多行匹配 g:global 全局匹配 常用的元字符 // [特殊元字符] \\D 非0-9之间的任意字符 \\d 0-9之间的一个数字 \\n 匹配一个换行符 \\b 匹配边界符 'zhu' (z左边u右边就是边界) \\s 匹配任意一个空白字符(包括制表符table键四个空格) \\w \"数字、字母、下划线\"中的任意一个 == ([0-9a-zA-Z]) \\ 转义字符(例如:\\d，把有特殊含义的字符转换为普通意思) . 代表是除了\\n以外任意字符 ^ 以某个元字符开头 $ 以某个元字符结尾 x|y x或者y中的任意一个 [xyz] x或者y或者z中的任意一个 [^xyz] 除了x/y/z以外任何一个字符 [a-z] 获取a-z中的任意字符 ([0-9] 等价于 \\d) [^a-z] 除了a-z之外的任意字符 () 正则分组 (?:) 当前分组只匹配不捕获 (?=) 正向预查 (?!) 反向预查 ...... // [量词元字符:让其左边的元字符出现多少次] * 出现零到多次 ？ 出现零到一次 + 出现一到多次 {n} 出现n次 {n,} 出现n到多次 {n,m} 出现n到m次 // [普通元字符] 只要在正则中出现的元字符，(在基于字面方式创建)，除了特殊和有量词意义的以外，其余的都是普通元字符 元字符 [ ] 详解 在[ ]中出现的元字符一般都是代表本身含义 [ ] 中出现的两位数，不是两位数，而是两个数字中的任意一个 // \\n 匹配换行符 let reg = /^\\n$/ console.log(reg.test('\\n')) //=>true console.log(reg.test('3')) //=>false console.log(reg.test('n')) //=>false //^开头 $结尾，那么代表的含义是只能是xx let reg = /^.$/ console.log(reg.test('n')) //=>true console.log(reg.test('1')) //=>true console.log(reg.test('\\n')) //=>false console.log(reg.test('nn')) //=>false // []中的字符有消除特殊含义的功能 let reg = /^[.]+$/ console.log(reg.test('..')) //=>true console.log(reg.test('n')) //=>false console.log(reg.test('1')) //=>false console.log(reg.test('\\n')) //=>false console.log(reg.test('nn')) //=>false // [\\d]依然是0-9中的一个数字 let reg = /^[\\d]$/ console.log(reg.test(0)) //=>true // [17] 匹配 1或者 7 let reg = /^[17]$/ console.log(reg.test('8')) //=>false console.log(reg.test('1')) //=>true console.log(reg.test('7')) //=>true // [12-93] 其实匹配的是 1或者3 2-9 let reg = /^[12-93]$/ console.log(reg.test('7')) //=>true // 匹配18-65岁之间 // 18~19 // 20~59 // 60~65 let reg = /^(1[89])|([2-5][0-9])|(6[0-5])$/ console.log(reg.test(\"55\")) // 匹配[Object AAAA] 必须使用\\转义 let reg = /^\\[object [A]{4}\\]$/ console.log(reg.test('[object AAAA]')) 常用正则 // 有效数字的正则 // 1.正数 负数 零 // 2.小数 整数 // 规则:1.可以出现+/-号，可以没有，也可以有一个 // 2.整数0 12 9：一位或者多位数字，一位0-9，多位数字不能以0开头 // 3.小数部分：可能有可能没有，有小数点后面至少要跟一位数字 let reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ console.log(reg.test('0.3')) // 手机号码的正则 // 1.11位数字 // 2.必须以1开头 let reg = /^1\\d{10}$/; console.log(reg.test(18554209912)) // 中文姓名的正则 // 1. [\\u4E00-\\U9FA5] 代表的是涵盖所有的中文 // 2.尼古拉斯·赵四 中间可能会有· let reg = /^[\\u4E00-\\u9FA5]{2,5}(·)?[\\u4E00-\\u9FA5]{2,}$/; console.log(reg.test('尼古拉斯·赵四')) console.log(reg.test('尼古拉斯')) exec() RegExp类的方法,传入要匹配的字符串 正则的捕获有懒惰性:执行一次exec()只能捕获第一个和正则匹配的内容，多次执行还是捕获第一个 不加g多次调用exec()方法也无法匹配到全部符合的字符串，加g可以多次执行exec()方法进行匹配符合的全部字符串，需要手动多次调用， // [ // '20190818', // index: 0, // input: '20190818changcheng2017', // groups: undefined // ] let reg = /\\d+/ let str = '20190818changcheng2017' // lastIndex导致了懒惰性只能捕获匹配的第一个 console.log(reg.exec(str)) 正则捕获的懒惰性 // exec():字符串捕获 let reg = /\\d+/ let str = '20190818changcheng2017' // lastIndex导致了懒惰性只能捕获匹配的第一个 console.log(reg.exec(str)[0]) //20190818 // 无法手动更改lastIndex实现全部捕获 reg.lastIndex = 17 console.log(reg.exec(str)[0]) // 20190818 // 解决惰性捕获添加g修饰符(唯一的方案，不加g不管用什么方法都没有办法全部匹配到) let reg = /\\d+/g; let str = '20190918chang20190817' console.log(reg.exec(str)) console.log(reg.exec(str)) let reg = /\\d+/g; let str = '20190918chang20190817cheng1807' // 完整的捕获方法实现 RegExp.prototype.myExecAll = function(str){ let result = [] valArray = this.exec(str) while(valArray){ result.push(valArray[0]) valArray = this.exec(str) } return result } console.log(reg.myExecAll(str)) 正则捕获的贪婪性 正则捕获还具有贪婪性，每一次匹配的时候，总是捕获到和正则匹配中最长的内容，例如:'2'符合/d+，'2019'也符合/d+，但是捕获的是最长的内容'2019' 把问号放到量词元字符后面，代表的不是出现0次或者1次了，而是取消捕获的贪婪性 // 可以匹配出全部的项 //[ '2019', index: 5, input: 'chang2019cheng', groups: undefined ] let str = 'chang2019cheng' let reg = /\\d+/g console.log(reg.exec(str)) // 加?可以取消正则匹配的贪婪性 //[ '2', index: 5, input: 'chang2019cheng', groups: undefined ] let str = 'chang2019cheng' let reg = /\\d+?/g console.log(reg.exec(str)) 分组捕获 //在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到(数组的第一项)， // 而且把小分组匹配到的内容也单独抽出来(数组中的第二项开始就是小分组) let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/g console.log(reg.exec(str)) // [ // '{123}', // '123', // index: 4, // input: '2018{123}{456}', // groups: undefined // ] match() String类的方法,参数是正则 不加g只能匹配到第一个符合的项，加g可以匹配出所有符合的项 match方法也有自己的局限性，在正则设置了g的情况下，基于match捕获的内容只有大正则匹配的的，小分组的没有单独抽离出来， （不设置g的情况下和执行exec()是一样的） // 设置g的情况下 // [ '{123}', '{456}' ] let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/g console.log(str.match(reg)) // [ // '{123}', // '123', // index: 4, // input: '2018{123}{456}', // groups: undefined // ] let str = '2018{123}{456}' let reg = /\\{(\\d+)\\}/ console.log(str.match(reg)) ？的作用 1.量词元字符:出现0次到1次 /-?/:让减号出现一次或者不出现 2.取消贪婪性 /\\d+?/:捕获的时候只捕获最短匹配的内容 3.?:只匹配不捕获 4.?=:正向预查 5.?!:负向预查 lastIndex的影响 // 调用test()方法之后，lastIndex值也会改变 let str = 'chang2019cheng2020'; let reg = /\\d+/g; console.log(reg.test(str)); // true 这里也相当于捕获修改了lastIndex的值 console.log(reg.lastIndex) // 9 console.log(reg.exec(str)); // [ '2020', index: 14, input: 'chang2019cheng2020', groups: undefined ] // 虽然捕获的不是同一个字符串，但是正则是同一个，上一次正则处理的时候修改了它的lastIndex值， // 也会对下一次匹配的字符串产生影响 let str = 'chang2019cheng2020'; let reg = /\\d+/g; console.log(reg.exec(str)); // [ '2019', index: 5, input: 'chang2019cheng2020', groups: undefined ] console.log(reg.exec('20180809cheng2020')) // [ '2020', index: 13, input: '20180809cheng2020', groups: undefined ] RegExp.$1 浏览器中RegExp.$1只有一个，其他的操作也会覆盖这个值，所以没什么用 let str = 'chang2019cheng2020' let reg = /(\\d+)/g; console.log(reg.test(str)) // true console.log(RegExp.$1) // 2019 获取的是一个小分组匹配的内容，大正则匹配的内容无法获取 console.log(reg.test(str)) // true console.log(RegExp.$1) // 2020 console.log(reg.test(str)) // false console.log(RegExp.$1) // 2020 console.log(reg.test(str)) // true console.log(RegExp.$1) // 2019 遍历到最后又会从头开始遍历 String.replace() // replace替换的第一种形式:传入字符串匹配 let str = 'chang2019chang2020' str = str.replace(/chang/g,'aaa') console.log(str) //aaa2019aaa2020 // replace替换的第二种形式:传入正则匹配 let str = 'chang{val:10}cheng{val:20}' str = str.replace(/\\{val:(\\d+)\\}/g,'aaa') console.log(str) //changaaachengaaa // replace替换的第三种形式:回调函数的替换 let str = 'chang{val:10}cheng{val:20}' str = str.replace(/\\{val:(\\d+)\\}/g,(...arg)=>{ return 'aaa' }) console.log(str) //changaaachengaaa 时间字符串格式化 // 简单版本:根据特殊符号匹配 function filterMonth(month){ if(month.length{ let [,index] = arg; console.log(arg) return arr[index] }) console.log(template) // 时间字符串格式化的终极解决方案 String.prototype.myFormateTime = function myFormateTime(template='{0}年{1}月{2}日 {3}时{4}分{5}秒'){ let ary = this.match(/\\d+/g).map(item=>(item{ return ary[index] }) } let str = '2018/4/30 12:5:30' console.log(str.myFormateTime()) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:58 "},"web/mvvm/":{"url":"web/mvvm/","title":"mvvm","keywords":"","body":" MVVM框架类 MVC View传送指令到Controller Controller完成业务逻辑之后要求model改变状态 model将新的数据发送给View,用户得到反馈 MVVM 优点：解决项目庞大之后Controller里的代码会越来越臃肿，于是有了viewModel，由类似于vue框架来处理,进行一个数据的传递，所以开发者只用关注model和view就可以了，相对于mvc，MVVM是双向数据绑定 阮一峰：MVVM http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html 3.双向绑定原理 Object.defineProperty 1.Object.defineProperty和Reflect.defineProperty的区别：Reflect.defineProperty返回的是Boolean值,Object.defineProperty返回的是一个新对象 MVVM的设计模式 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-03-16 11:31:43 "},"web/netWork/":{"url":"web/netWork/","title":"浏览器","keywords":"","body":" 一个页面从输入 url 到页面加载完成显示，这个过程做了什么 1.浏览器通过 dns 解析将 url 地址解析为 ip（如果有缓存直接返回缓存,否则递归解析） 2.通过 dns 解析得到目标地址的 ip，与服务器建立 tcp 连接 ip 协议：选择传输路线，负责找到 tcp 协议:三次握手，分片，可靠传输，重新发送机制 三次握手，四次挥手 TCP 三次握手：1、客户端发送 syn 包到服务器，等待服务器确认接收。2、服务器确认接收 syn 包并确认客户的 syn，并发送回来一个 syn+ack 的包给客户端。3、客户端确认接收服务器的 syn+ack 包，并向服务器发送确认包 ack，二者相互建立联系后，完成 tcp 三次握手。四次挥手就是中间多了一层 等待服务器再一次响应回复相关数据的过程 浏览器通过 http 协议发送请求(增加 http 的报文信息) 服务器接收请求后，查库，读文件，拼接返回的 http 相应 浏览器收到 html，然后渲染 解析 html 为 dom,解析 css 为 css-tree,最终生成 render-tree,阻塞渲染 遍历渲染树开始布局，计算每个节点位置大小信息 将渲染树的每个节点绘制到屏幕 加载 js 文件，执行 js 脚本 reflow（样式）,repaint（位置） OSI 协议 互联网的本质就是一系列网络协议，这个协议就叫做 OSI 协议，可以划分为七层 物理层，数据链路层，会话层，表示层，应用层，传输层，网络层 应用层:HTTP,FTP，DNF（与其他计算机进行通讯的一个应用服务，向应用提供应用服务时的通信活动） 传输层:TCP（可靠） UDP 数据传输(HTTP-TCP DNS-UDP),UDP 一般是用来网络直播 网络层:IP 选择传输路线(通过 IP 地址和 mac 地址)(使用 ARP 协议进行 mac 地址进行通信) 链路层:网络连接的硬件部分 http 和 https 的区别 Http 的缺陷: http 不具备加密功能，http 报文使用明文发送 无法确认你发送到的服务器就是真正的服务器 无法阻止海量请求下的 dos 攻击 返回的内容被篡改 Https 是 Http 建立在 SSL/TLS 安全协议上的(信息加密，完整校验，身份验证) Http 相关 Header 内容 1.缓存 Header 强 Cache-Control / expires private 客户端可以缓存 public 客户端和代理服务器都可以缓存 max-age=60 缓存内容将在 60 秒后失效 no-cache 需要使用对比缓存验证数据,需要向服务器发送验证 no-store 所有内容都不会缓存，强制缓存和对比缓存都不会触发(不缓存) 2.跨域：Access-control 3.压缩：Content-Encoding:gzip 4.范围请求：range 5.防盗链：referer(经常用于图片防盗，判断 referer 的请求地址) 6.用户内核：user-agent 7.单主机多域名：host 8.多语言：accept-language Tcp 连接 navigator.userAgent 的作用 判断浏览器类型，采用兼容方案 判断是否是移动端 标识 H5 容器，方便调用 H5 接口 userAgent 的伪装成本很低，不要过于依赖 const desPort = 80; const desHost = '123.57.205.204'; let allBuffer = null; const net = require('net') // 创建一个TCP服务器 const client = net.createConnection(8080,127,0.0.1,function(){ console.log('connect to sercer!') client.write( 'GET / HTTP1.0\\r\\nHost:www.zhufengpeixun.cn\\r\\nUser-Agent:Mozilla/5.0(Macintosh;Intel Mac OS X 10_12_1) AppleWebkit/537.36(KHTML,like Gecko)chrome/64.0.3282.186 Safari/537.36\\r\\nAccept:text/html\\r\\nAccept-Language:zh-CN,zh;q=0.9\\r\\n\\r\\n' ) }) // client.on('data',function(data){ console.log('----receive data-------'); if(!allBuffer){ allBuffer = data; }else{ allBuffer = Buffer.concat([allBuffer,data]); } }) client.on('error',function(err){ console.log(err); }) client.on('end',function(){ console.log('connection end'); const htmlContent = allBuffer.toString(); // 解释页面的操作 const ws = fs.createWriteStream( path.join(__dirname,'zhufeng.html') ) ws.write(htmlContent) }) 浏览器内核知识 浏览器内核:我们可以初步认为浏览器中负责将页面的字符转变成可视化图像的模块就是浏览器内核 通过相应的内容，我们可以看到内容中还存在很多外联资源，浏览器是如何处理的？ 不同的外联资源，webkit 有不同的加载器，当浏览器解析到 url 地址时，调用特定的资源加载器，如果不是特殊资源，加载过程不会阻塞渲染过程。 著名的优化：”css 放在头部，js 放在尾部“，为什么？ 一般来说 css 不会阻塞渲染过程，但 javaScript 资源在浏览器当中，会阻塞渲染过程的进行，如果放置在头部，渲染过程会暂停，造成\"白屏\"效果，但是现代浏览器优化做的很好，所以当阻塞渲染时，浏览器会开启新的线程继续渲染 浏览器在渲染之前或之后应该做哪些事情？ 渲染之前会加载资源，渲染之后在 dom 或者 css 变化之后，重新进行布局计算和重渲染操作 移动端的浏览器和 pc 的刘安琪是否相同？ 功能基本相同，但所运行的操作系统不同，渲染机制有差异 网页内容的组成 charset：设置 html 文档的字符编码 1. doctype：提供浏览器 html 版本信息 head：html 头部 viewPort:设置用户的可视区域 1. width:控制 viewPort 的大小 height:和 width 对应，指定高度 initial-scale:初始用户缩放比例，也即是当页面第一 load 的缩放比例 maximum-scale：允许用户缩放的最大比例 minimum-scale:允许用户缩放的最小比例 user-scalable:用户是否可以手动缩放 name:设置文档的名称 charset:关键词，即用于说明网页包含的关键信息等，从而提高被搜索引擎搜索到的概率，一般设置多个关键字 1. keywords:关键词，即用于说明网页包含的关键信息等，从而提高被搜索引擎搜索到的概率，一般设置多个关键字 1. description:描述，用于描述网页的内容，主题等，最多容纳 1024 个字符，但是搜索引擎只展示前 175 个字符 1. author:作者 1. robots:机器人，seo 优化 1. http-equiv:相当于 http 文件头作用，向浏览器传回一些有用信息 expires：期限,可以用于网页的到期时间，一旦网页过期，必须到服务器重新上传 ＜meta http-equiv=\"expires\" content=\"Wed, 20 Jun 2007 22:33:00 GMT\"＞ set-cookie:如果网页到期，存盘的 cookie 将删除 ＜meta http-equiv=\"Set-Cookie\" content=\"cookievalue=xxx;expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/\"＞ content-type:设置显示字符集 1. Content-Language:设置语言 1. Http 协议类 http 主要特点 简单快速 灵活 无连接 无状态 http 报文组成 请求报文 请求行：http 方法，页面地址,http 协议，版本 请求头 User-Agent：产生请求的浏览器类型 Accept：客户端可识别的内容类型列表 Host：请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机。 空行 告诉服务端下面是请求体了 请求体 请求内容 3.响应报文：状态码，响应头，空行，响应体 4.Http 方法 Get:获取资源 Post:传输资源 Put：更新资源 Delete:删除资源 Head:获取报文首部 5.GET 和 Post 的区别 GET 回退时是无害的，而 post 会再次请求 get 的 url 是可以被收藏的，但 post 不行 get 会被浏览器主动缓存，而 post 不会，除非手动设置 get 只能进行 Url 编码，而 post 支持多种编码方式 get 参数会被完整保留在浏览器的历史记录中，而 post 不会 get 参数在 url 传送的参数有长度限制，而 post 没有限制 get 参数只接受 ASCII 字符，而 post 没有限制 get 比 post 更不安全，因为参数会暴露在 url 上，所以不能用来传递敏感信息 get 参数通过 url 传递，post 放在 requsetBody 中 6.Http 状态码 1xx 指示信息:代表请求已经被接收正在处理 2xx 成功:代表请求已经被成功接收 3xx 重定向:要完成请求必须进行进一步操作 4xx 客户端错误:请求有语法错误或者请求无法实现 5xx 服务器错误:服务器未能实现合法的请求 常用的状态码 204:没有相应内容 206:客户发送一个带有 Range 头的 get 请求，客户端完成了它，一般用来音频视频的分段播放，用来传递范围区间 301:所请求页面已转移到新的 Url，永久重定向 302:所请求页面已经转移到新的 url 304:客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以用 400:客户端语法有错误，不能被服务器理解 401:请求未经授权 403:对请求页面的访问被禁止 503:负载均衡挂了 7.Http 持久连接 keep-Alive，(1.1 版本才支持)当使用此功能时，keep-alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求的时候，keep-alive 功能避免了建立或者重新创建连接 8.http 管线化 什么是管线化 在使用持久连接的情况下，某个连接消息的传递类似于 请求 1 -> 响应 1 -> 请求 2 -> 响应 2 管线化:某个连接上的消息变成了类似这样 请求 1 -> 请求 2 -> 请求 3 -> 响应 1 -> 响应 2 -> 响应 3 【注】 那么持久连接和管线化的区别在于： 持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求 1 的响应收到之后，才会发送请求 2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。实现并行发送请求 只有 GET 和 HEAD 要求可以进行管线化，而 POST 则有所限制 初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。 4.HTTP1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器 Chrome 和 Firefox 默认并未开启管线化支持。 9.http 的多路复用 在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。 HTTP/2 的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。 通信类 服务器同源策略(协议，域名，端口) 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互， 这是一个用来隔离恶意文件关键的安全机制 cookie，LocalStorage,indexDB 无法读取 DOM 无法获得 ajax 无法发送 前后端如何通信 ajax webSocket CORS：跨域请求，后端设置请求头许可，Access-Control-Allow-Origin：* 手写原生 ajax 请求 function request(option) { if (String(option) !== '[object Object]') return undefined option.method = option.method ? option.method.toUpperCase() : 'GET' option.data = option.data || {} var formData = [] for (var key in option.data) { formData.push(''.concat(key, '=', option.data[key])) } option.data = formData.join('&') if (option.method === 'GET') { option.url += location.search.length === 0 ? ''.concat('?', option.data) : ''.concat('&', option.data) } var xhr = new XMLHttpRequest() xhr.responseType = option.responseType || 'json' xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status === 200) { if (option.success && typeof option.success === 'function') { option.success(xhr.response) } } else { if (option.error && typeof option.error === 'function') { option.error() } } } } xhr.open(option.method, option.url, true) if (option.method === 'POST') { xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') } xhr.send(option.method === 'POST' ? option.data : null) } // 调用 request({ url: 'api', method: 'POST', data: {}, success: function (res) { }, error: function (err) { } }) 跨域通信的几种方式 JSONP:动态加载 script 脚本，传回调名，然后获取函数里面的参数，arguments[0] Hash // 伪代码 // 利用hash，场景是当前页面A通过iframe嵌入跨域的页面B // A中的代码 var B = document.getElementsByTagName(\"iframe\"); B.src = B.src + '#' + 'data' //在B中的代码 window.onhashchange = function(){ var data = window.location.hash; } postMessage // postMessage // 窗口A(http://A.com)向跨域的窗口B(http://B.com)发送信息 Bwindow.postMessage('data','http://B.com'); //在B窗口中监听 window.addEventListener('message',function(event){ console.log(event.origin) // http://A.com console.log(event.source) // Bwindow console.log(event.data) // 'data' }) WebSocket var ws = new WebSocket(\"wss://echo.websocket.org\"); // 建立连接，发送消息 ws.open = function(evt){ console.log(\"Connection open ...\"); ws.sned(\"This is message\"); } // 监听发送消息 ws.onmessage = function(evt){ console.log(\"Recived Message:\"+evt.data) ws.close() } // 监听关闭 ws.onclose = function(evt){ console.log(\"connection closed\") } CORS // CORS // url(必须) options(可选) fetch(\"http://W.JSON\",{ }).then(function(response){ }).catch(function(err){ // 出错的，等于then的第二个参数 }) 安全类 CSRF 因为登陆了网站 A 之后，已经下发了 cookie，点击 B 网站的时候,诱导发送 get 请求,这时候的话用户发送的请求就携带 cookie 了 攻击条件: 在 A 网站已经登陆过，如果没有登录肯定拿不到 cookie，就会让他登录 接口存在未校验 refer 等情况 解决方案: 后台校验请求头的 refer token 验证 隐藏令牌:隐藏在 header 头当中，把信息校验 XSS 跨域脚本攻击 攻击方式：输入框脚本注入 浏览器渲染机制 什么是 DOCTYPE 以及作用 DOCTYPE 是用来声明文档类型和 DTD 规范的，一个主要用途是文件合法性校验，如果文件代码不合法，那么浏览器解析便会出一些差错。 HTML5 HTML 4.0 有两个模式：严格模式和宽松模式 DOM: Document Object Model，浏览器将 HTML 解析成树形的数据结构，简称 DOM CSSOM: Css Object Model,浏览器将 CSS 解析成树形的数据结构，简称 CSSOM Render Tree: DOM 和 CSSOM 合并生成 Render Tree Layout: 计算出 Render Tree 每个节点的具体位置 Painting: 通过显卡，将 Layout 后的节点内容分别呈现在屏幕上 加载顺序： 当我们获取到 HTML 文件的时候，会自上而下进行加载，并在加载过程中解析和渲染 加载说的是获取资源文件的过程，如果在加载过程当中遇到外部的 css 文件和图片，浏览器会发送请求获取 css 文件和图片，这个过程是异步的，并不会影响 HTML 文件的加载 但是如果遇到 Js 文件，HTML 文件会挂起，等待 js 文件加载完再进行渲染 为什么 HTML 文件会等待 Js 文件加载，因为 JS 可以操作 DOM，导致后续 HTML 资源白白加载，所以会等待 JS 文件加载完成之后再进行渲染，所以 JS 文件引入要在 body 底部 重排(reflow) DOM 结构当中各个元素都有自己的盒子模型，这些都需要浏览器根据各种样式来计算结果放在它该出现的位置，这个过程称为回流 触发回流的条件 增加，删除，修改 DOM 节点，会导致回流或者重绘 移动 DOM 位置，css 动画之类的 修改 css 样式的时候 resize 窗口的时候 修改网页默认字体的时候 重绘(repaint) 当各种盒子的位置，大小，以及其他属性，例如颜色，字体大小确定下来的时候，浏览器便把这些元素按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之重绘制(repaint) 触发重绘条件 DOM 改动 CSS 改动 如何降低重绘带来的影响 使用 DocumentFragment 一次将节点添加进去，不过此方法在 IE 情况下并不会提速 5.介绍下重绘和回流 回流必定会发生重绘，重绘不一定会引发回流 提升页面性能的几种方法 异步加载的方式 动态脚本加载，defer，async 异步加载的区别 defer 实在 html 加载完毕之后才会执行,如果多个，按照加载的顺序依次进行执行 async 是在加载完成之后立即执行，如果是多个,执行顺序和加载顺序无关 浏览器缓存 缓存的分类 （1）强缓存 不会向服务器发送请求，直接从缓存中读取数据，在 chrome 浏览器当中的 netWork 中能看到返回码是 200 1) 强缓存 Expires: Tue, 13 Aug 2019 08:23:24 GMT // response header里的过期时间，如果在这个时间内，则命中强缓存 Cache-Control: Cache-Control:max-age=3600 //60分钟内再次请求该资源就会命中强缓存 Cache-Control:no-cache //不使用本地缓存，需使用协商缓存 no-store //禁止浏览器缓存数据，每次用户请求资源，都会向服务器发送一个请求 public //可以被所有用户缓存 private//只能被终端的浏览器缓存，不允许cdn等缓存服务器缓存 // 如果两个标识符都有，按照最后一个为准 （2）协商缓存 向服务器发送请求，服务器会根据请求头中的参数来判断是否命中协商缓存，如果命中，则返回 304 的状态并带上新的 response header 通知浏览器从缓存中读取资源 1) 协商缓存 Last-Modified:Tue, 13 Aug 2019 08:23:24 GMT //标识该资源最后修改的时间 Etag：hash值 //告诉浏览器此文件在服务器的唯一标识 资源压缩合并，减少 http 请求 面向对象的事件委托 优点:减少 dom 循环遍历，优化性能，采用绑定在父元素的方法，子元素点击冒泡 1x 2x 3x 4x class addEv{ constructor(el){ var dom = document.querySelectorAll(el)[0] this.el = dom dom.addEventListener(\"click\",(evnet=>{ if(event.target.className.indexOf(\"del\") > -1){ this.removeAddListener(evnet.target) } })) } removeAddListener(childNode){ this.el.removeChild(childNode.parentNode) } } window.addEventListener('DOMContentLoaded',()=>{ new addEv('.content') }) 前端错误监控 即时运行的错误 try catch window.onerror()：错误回传服务器，但是有跨域问题，需要在 js 文件引入的时候加上 crossorigin 资源加载的错误 object.onerror(): 例如图片之类的地址加载失败，可以在标签上添加 onerror 函数，然后相对应的函数内写捕获错误的具体代码 performance.getEntries():获取加载资源的各项数据，大小，时间等等 自定义 error 事件：window.addEventListener 错误上报的原理 ajax 上传 利用 img 对象上报 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-14 11:03:59 "},"web/data.html":{"url":"web/data.html","title":"数据类型","keywords":"","body":" 前端数据结构 队列 栈 链表 集合 hash 表 树 图 队列:先进先出 class Queue { constructor() { this.queue = [] } enqueue(element) { this.queue.push(element) } dequeue() { this.queue.shift() } } let newQueue = new Queue(); newQueue.enqueue(1) newQueue.enqueue(2) newQueue.dequeue() console.log(newQueue.queue) 栈:后进先出 // 执行上下文栈:执行a执行b执行c 然后 销毁c销毁b销毁a,是从里往外的，闭包就是执行上下文没有被销毁 function a(){ function b(){ function c(){ } c() b() } a() 栈结构模拟 class Stack { constructor() { this.stack = [] } put(element) { this.stack.push(element) } pop() { this.stack.pop() } } let newStack = new Stack(); newStack.put(1) newStack.put(2) newStack.pop() console.log(newStack.stack) 链表 单项链表 双向链表 循环链表 操作数据不需要破坏数据的原有结构 链表的性能要优于数组，因为数组是强顺序 class Node { constructor(element) { this.element = element this.next = null } } class LinkList { constructor() { this.head = null this.length = 0 } insert(position, element) { let node = new Node(element) if (!this.head) { this.head = node } else { let index = 0 let current = this.head let previous = null while (index++ 集合 set 的特点就是 key 和 value 是相同的 class Set { constructor() { this.set = {} } add(element) { if (!this.set.hasOwnProperty(element)) { this.set[element] = element } } } let a = new Set() a.add(1) a.add(2) console.log(a) 集合重点：交集差集 // 数组的交集 和 差集 has来实现 set方法只有forEach方法 let s1 = new Set([...a1]); // [1,2,3] let s2 = new Set([...a2]); // [1,2,3] let a3 = [...s2].filter((item=>{ // 返回的是一个新的数组 return !s1.has(item); // map是映射一个新的数组 但是不会比以前的项少 })); console.log(a3); map 原理 : 生成唯一的 key，存放对应的值 hashTable 取值快 而且 es6 已经提供了 class Map{ // 松散 重复的话可以在加上链表 constructor(){ this.arr = []; } calc(key){ let total = 0; for(let i = 0 ; i 二叉树 class Node { constructor(element) { this.element = element; this.left = null; this.right = null; } } class Tree { constructor() { this.root = null } insert(newNode, element) { // 如果小于 if (element 十进制转二进制 function binarySystem(shang, arr = []) { if (Math.floor(shang / 2) != 0) { arr.push(shang % 2) binarySystem(Math.floor(shang / 2), arr) } else { arr.push(shang) } return arr.join('') } console.log(binarySystem(58)) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-10 14:05:52 "},"web/algorithm.html":{"url":"web/algorithm.html","title":"常见算法题","keywords":"","body":" 函数的柯里化 function add() { let args = Array.prototype.slice.call(arguments) let _add = function() { args.push(...arguments) return _add } // 利用隐式类型转换，最后一次执行的时候返回值 _add.toString = function() { let result = args.reduce((prev, current) => { return prev + current }) return result } return _add } console.log(add(1)(2)(3) == 6) console.log(add(1, 2, 3) == 6) console.log(add(1, 2)(3) == 6) 冒泡排序 var arr = [5, 2, 33, 12, 9, 1] function sort(arr) { for (var i = 0; i 选择排序 var arr = [5, 2, 33, 12, 9, 1] function sort(arr) { for (let i = 0; i 插入排序 function insert(arr) { // 准备一个数组，用来存储手里的牌，默认抓第一张 let currentArr = [] currentArr[0] = arr[0] for (let i = 1; i = 0; j--) { // 每次拿新抓的牌和放在数组中的牌进行比较，如果大，就放在后面 console.log(newCurrent, currentArr[j]) if (newCurrent > currentArr[j]) { currentArr.splice(j + 1, 0, newCurrent) break; } // 如果都比之前的牌小，那就放在最前面 if (j == 0) { currentArr.unshift(newCurrent) } } } } var arr = [5, 7, 33, 12, 9, 1] insert(arr) 希尔排序 Array.prototype.shell = function() { let gap = Math.floor(this.length / 2) while (gap >= 1) { for (let i = gap; i = 0 && this[i] 快速排序 function quick(arr) { if (arr.length 数组扁平化 var a = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] console.log(a.flat(Infinity)) var a = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] arr.toString().split(',') var arr = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] function demo(arr) { let result = [] let fn = (arr) => { arr.forEach((item) => { if (Object.prototype.toString.call(item) == '[object Array]') { fn(item) } else { result.push(item) } }) } fn(arr) return result } console.log(demo(arr)) 输入一个 N，输出所有和为 N 的连续正数序列 function createArr(i, j) { let arr = new Array(j) arr.fill(null) arr = arr.map((item, index) => { return i++ }) return arr } // 中间一份为二。中间的数加后面任意的数都大于目标数 function fn(count) { let result = [] let middle = Math.ceil(count / 2) // 从1开始累加 for (let i = 1; i count) { break } else if (total == count) { result.push(createArr(i, j)) break } } } return result } console.log(fn(15)) 找出数组中和为 N 的两个正数，并返回他们的数组下标 var arr = [1, 6, 4, 8, 7] function func(nums, target) { for (var i = 0; i var arr = [1, 0, 3, 8, 7] function fn(nums, target) { let obj = {} for (var i = 0; i 具有最大和的连续子数组 let arr = [-2, 2, -1, 3, -3] function maxSubArray(arr) { // 假设第一项是最大值 let ans = arr[0] let sum = 0 for (let i = 0; i 0) { sum = sum + arr[i] } else { sum = arr[i] } ans = Math.max(ans, sum) } return ans } console.log(maxSubArray(arr)) 合并两个有序数组 var a = [1, 321, 421, 5215] var c = [41, 432, 532, 5] var d = a.concat(c).sort((a, b) => a - b) console.log(d) let arr1 = [1, 5, 8, 16, 26] let arr2 = [4, 7, 9, 17] function sort(arr1, arr2) { // 总索引 let len = arr1.length + arr2.length - 1 let len1 = arr1.length - 1 let len2 = arr2.length - 1 while (len1 >= 0 && len2 >= 0) { if (arr1[len1] > arr2[len2]) { arr1[len] = arr1[len1] len1-- } else if (arr1[len1] // 斐波那契数列 [1,1,2,3,5,8,13,21...] function fibonacci(count) { if (count 0) { let current = arr[arr.length - 1] let next = arr[arr.length - 2] arr.push(current + next) n-- } return arr } console.log(fibonacci(4)) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:40:47 "}}